package com.sos.VirtualFileSystem.Options;
import java.io.File;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;

import org.apache.log4j.Logger;

import sos.configuration.SOSConfiguration;
import sos.net.mail.options.SOSSmtpMailOptions;
import sos.util.SOSStandardLogger;

import com.sos.JSHelper.Annotations.JSOptionClass;
import com.sos.JSHelper.Exceptions.JSExceptionMandatoryOptionMissing;
import com.sos.JSHelper.Exceptions.JobSchedulerException;
import com.sos.JSHelper.Listener.JSListener;
import com.sos.JSHelper.Options.SOSOptionAuthenticationMethod.enuAuthenticationMethods;
import com.sos.JSHelper.Options.SOSOptionElement;
import com.sos.JSHelper.Options.SOSOptionHostName;
import com.sos.JSHelper.Options.SOSOptionJadeOperation.enuJadeOperations;
import com.sos.JSHelper.Options.SOSOptionPortNumber;
import com.sos.JSHelper.Options.SOSOptionRegExp;
import com.sos.JSHelper.Options.SOSOptionString;
import com.sos.JSHelper.Options.SOSOptionTime;
import com.sos.JSHelper.Options.SOSOptionTransferType;
import com.sos.JSHelper.Options.SOSOptionTransferType.enuTransferTypes;
import com.sos.VirtualFileSystem.Factory.VFSFactory;
import com.sos.VirtualFileSystem.common.SOSVfsMessageCodes;
import com.sos.i18n.annotation.I18NResourceBundle;

/**
* \class SOSFTPOptions
*
* \brief SOSFTPOptions -
*
* \details
*
* \codeadd
*   .... code goes here ...
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author KB
* @version $Id$16.05.2010
* \see reference
*
* Created on 26.07.2010 20:52:28
 */
/**
 * @author KB
 *
 */
@I18NResourceBundle(
					baseName = "SOSVirtualFileSystem",
					defaultLocale = "en")
public class SOSFTPOptions extends SOSFtpOptionsSuperClass {
	private static final String		conFileNameExtensionJADEConfigFile	= ".jadeconf";
	@SuppressWarnings("unused")
	private static final String		conSVNVersion						= "$Id$";
	public static final String		conURIPrefixFILE					= "file://";
	// TODO this *must* be a static global constant
	public static final String		conSchedulerEnvVarPrefix			= "scheduler_param_";
	// TODO über einen Parameter vorgeben lassen
	public static final String		conSOSFtpEnvVarPrefix				= "sosftp_";
	public static final String		conVariableEND						= "}";
	public static final String		conSystemPropertyFILE_SEPARATOR		= "file.separator";
	private static final String		conOperationSEND					= "send";
	public static final String		conOperationRECEIVE					= "receive";
	/**
		 *
		 */
	private static final long		serialVersionUID					= -8219289268940238015L;
	private final String			conClassName						= "SOSFTPOptions";
	private static final Logger		logger								= Logger.getLogger(VFSFactory.getLoggerName());
	private Properties				propSOSFtpEnvironmentVars			= null;
	private Properties				schedulerParams						= null;
	private boolean					flgCheckMandatoryDone				= false;
	private boolean					flgReadSettingsFileIsActive			= false;
	private boolean					flgSettingsFileProcessed			= false;
	// Map<String, String> variables = null;
	private Properties				propAllEnvironmentVariables			= null;
	@JSOptionClass(
					description = "objConnectionOptions",
					name = "SOSConnection2Options")
	private SOSConnection2Options	objConnectionOptions;
	@JSOptionClass(
					description = "objMailOptions",
					name = "objMailOptions")
	private SOSSmtpMailOptions		objMailOptions;
	public boolean					flgCumulativeTargetDeleted			= false;

	public SOSFTPOptions(final SOSOptionTransferType.enuTransferTypes penuTransferType) {
		super();
		switch (penuTransferType) {
			case webdav:
				auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				this.Source().auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				this.Target().auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.webdav.Text(), SOSOptionTransferType.enuTransferTypes.webdav.Text());
				this.Source().protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.webdav.Text(),
						SOSOptionTransferType.enuTransferTypes.webdav.Text());
				this.Target().protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.webdav.Text(),
						SOSOptionTransferType.enuTransferTypes.webdav.Text());
				port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				this.Source().port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				this.Target().port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				break;
			case http:
				auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				this.Source().auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				this.Target().auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.http.Text(), SOSOptionTransferType.enuTransferTypes.http.Text());
				this.Source().protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.http.Text(), SOSOptionTransferType.enuTransferTypes.http.Text());
				this.Target().protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.http.Text(), SOSOptionTransferType.enuTransferTypes.http.Text());
				port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				this.Source().port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				this.Target().port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				break;
			default:
				break;
		}
		//
	}

	public SOSFTPOptions(final SOSOptionTransferType.enuTransferTypes penuTransferTypeSource,
			final SOSOptionTransferType.enuTransferTypes penuTransferTypeTarget) {
		super();
		switch (penuTransferTypeSource) {
			case webdav:
				auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.webdav.Text(), SOSOptionTransferType.enuTransferTypes.webdav.Text());
				port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				break;
			default:
				break;
		}
		this.changeDefaults(penuTransferTypeSource, this.Source());
		this.changeDefaults(penuTransferTypeTarget, this.Target());
	}

	private void changeDefaults(final SOSOptionTransferType.enuTransferTypes penuTransferType, final SOSConnection2OptionsAlternate pobjOpt) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::changeDefaults";
		switch (penuTransferType) {
			case webdav:
				pobjOpt.auth_method.changeDefaults(enuAuthenticationMethods.url.text, enuAuthenticationMethods.url.text);
				pobjOpt.protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.webdav.Text(), SOSOptionTransferType.enuTransferTypes.webdav.Text());
				pobjOpt.port.changeDefaults(SOSOptionPortNumber.conPort4http, SOSOptionPortNumber.conPort4http);
				break;
			case local:
			case file:
				pobjOpt.auth_method.changeDefaults(enuAuthenticationMethods.password.text, enuAuthenticationMethods.password.text);
				pobjOpt.protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.local.Text(), SOSOptionTransferType.enuTransferTypes.local.Text());
				pobjOpt.port.changeDefaults(0, 0);
				break;
			case ftp:
				pobjOpt.auth_method.changeDefaults(enuAuthenticationMethods.password.text, enuAuthenticationMethods.password.text);
				pobjOpt.protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.ftp.Text(), SOSOptionTransferType.enuTransferTypes.ftp.Text());
				pobjOpt.port.changeDefaults(SOSOptionPortNumber.conPort4FTP, SOSOptionPortNumber.conPort4FTP);
				break;
			case sftp:
				pobjOpt.auth_method.changeDefaults(enuAuthenticationMethods.password.text, enuAuthenticationMethods.password.text);
				pobjOpt.protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.sftp.Text(), SOSOptionTransferType.enuTransferTypes.sftp.Text());
				pobjOpt.port.changeDefaults(SOSOptionPortNumber.conPort4SFTP, SOSOptionPortNumber.conPort4SFTP);
				break;
			case ftps:
				pobjOpt.auth_method.changeDefaults(enuAuthenticationMethods.password.text, enuAuthenticationMethods.password.text);
				pobjOpt.protocol.changeDefaults(SOSOptionTransferType.enuTransferTypes.ftps.Text(), SOSOptionTransferType.enuTransferTypes.ftps.Text());
				pobjOpt.port.changeDefaults(SOSOptionPortNumber.conPort4FTPS, SOSOptionPortNumber.conPort4FTPS);
				break;
			default:
				break;
		}
	} // private void changeDefaults

	public SOSFTPOptions() {
		super();
		//
	}

	public SOSSmtpMailOptions getMailOptions() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getMailOptions";
		if (objMailOptions == null) {
			objMailOptions = new SOSSmtpMailOptions();
		}
		return objMailOptions;
	} // private SOSSmtpMailOptions getMailOptions

	/**
	 * \brief SOSFTPOptions
	 *
	 * \details
	 *
	 * @param pobjListener
	 */
	@Deprecated
	public SOSFTPOptions(final JSListener pobjListener) {
		super(pobjListener);
	}

	/**
	 * \brief SOSFTPOptions
	 *
	 * \details
	 *
	 * @param JSSettings
	 * @throws Exception
	 */
	public SOSFTPOptions(final HashMap<String, String> JSSettings) throws Exception {
		super(JSSettings);
		//		setChildClasses(JSSettings);
	}

	public void setChildClasses(final Properties pobjProperties) {
		HashMap<String, String> map = new HashMap<String, String>((Map) pobjProperties);
		try {
			this.setChildClasses(map);
		}
		catch (Exception e) {
			logger.error(e.getLocalizedMessage());
		}
	}

	private void setChildClasses(final HashMap<String, String> JSSettings)  {
		try {
			if (objConnectionOptions == null) {
				objConnectionOptions = new SOSConnection2Options(JSSettings);
				objMailOptions = new SOSSmtpMailOptions(JSSettings);
			}
			else {
				objConnectionOptions.setPrefixedValues(JSSettings);
			}
		}
		catch (Exception e) {
			throw new JobSchedulerException(e);
		}
	}

	public void adjustDefaults() {
		if (operation.Value().equalsIgnoreCase(enuJadeOperations.move.Text())) {
			remove_files.value(true);
			remove_files.setProtected(operation.isProtected());
		}
		if (TransactionMode.isTrue()) {
			if (isAtomicTransfer() == false) {
				atomic_suffix.Value("~");
			}
		}
		if (operation.Value().equalsIgnoreCase(enuJadeOperations.getlist.Text())) {
			remove_files.value(false);
		}
		String localDir = local_dir.Value();
		if (isEmpty(localDir) == true) {
			local_dir.Set(SourceDir);
			localDir = local_dir.Value();
		}
		checkReplaceAndReplacing(Target());
		checkReplaceAndReplacing(Source());
		if (replacing.IsNotEmpty() && replacement.IsNull()) {
			replacement.Value("");
		}
		if (this.Target().protocol.isDirty()) {
			if (protocol.isDirty() == false) {
				protocol.Set(this.Target().protocol);
			}
		}
		setDefaultHostPort(protocol, port, host);
		setDefaultHostPort(this.Source().protocol, this.Source().port, this.Source().host);
		setDefaultHostPort(this.Target().protocol, this.Target().port, this.Target().host);
		setDefaultHostPort(this.Source().Alternatives().protocol, this.Source().Alternatives().port, this.Source().Alternatives().host);
		setDefaultHostPort(this.Target().Alternatives().protocol, this.Target().Alternatives().port, this.Target().Alternatives().host);
		getDataSourceType();
		getDataTargetType();
	}

	/**
	 *
	 * \brief CheckMandatory
	 *
	 * \details
	 *
	 * \return
	 * @throws JSExceptionMandatoryOptionMissing, Exception
	 *
	 */
	@Override public void CheckMandatory() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::CheckMandatory";
		if (flgCheckMandatoryDone == true) {
			return;
		}
		operation.CheckMandatory();
		if (operation.Value().equalsIgnoreCase(enuJadeOperations.move.Text())) {
			remove_files.value(true);
		}
		if (TransactionMode.isTrue()) {
			if (isAtomicTransfer() == false) {
				atomic_suffix.Value("~");
			}
		}
		if (operation.Value().equalsIgnoreCase(enuJadeOperations.getlist.Text())) {
			remove_files.setFalse();
		}
		checkURLParameter(this.getConnectionOptions().Source());
		checkURLParameter(this.getConnectionOptions().Target());
		
		String strSourceP = Source().getprotocol().Value();
		String localDir = local_dir.Value();
		if (isEmpty(localDir) == true) {
			local_dir.Value(SourceDir.Value());
			localDir = local_dir.Value();
			localDir += "";
		}
		if (Source().url.isDirty() && SourceDir.isNotDirty()) {
			SourceDir.Value(Source().url.getFolderName());
		}
		if (Target().url.isDirty() && TargetDir.isNotDirty()) {
			TargetDir.Value(Target().url.getFolderName());
		}
		/**
		 * credentialStore?
		 */
		checkCredentialStore(Source());
		checkCredentialStore(Target());
		if (Source().replacing.IsNotEmpty() && Source().replacement.IsNotEmpty()) {
			remove_files.setFalse();
		}
		super.CheckMandatory();
		// TODO mandatory options in datatarget/datasource prüfen. Interface erweitern um checkmandatory
		// TODO in die Options-Klasse, falls nicht schon drin ist ....
		if (localDir.startsWith("\\\\")) {
			while (localDir.indexOf("\\") != -1) {
				localDir = localDir.replace('\\', '/');
			}
		}
		local_dir.Value(localDir);
		// TODO in die Options-Klasse, falls nicht schon drin ist ....
		if (localDir.startsWith(conURIPrefixFILE)) {
			if (new File(createURI(localDir)).exists() == false) {
				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0010.params(localDir));
			}
		}
		checkReplaceAndReplacing(Target());
		checkReplaceAndReplacing(Source());
		if (replacing.IsNotEmpty() && replacement.IsNull()) {
			replacement.Value("");
		}
		if (replacing.IsEmpty() && replacement.IsNotEmpty()) {
			throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0020.params(replacement.getKey(), replacing.getKey()));
		}
		if (append_files.value() == true) {
			String strAppendFilesKey = append_files.getKey();
			if (isAtomicTransfer()) {
				String strT = getOptionNamesAsString(new SOSOptionElement[] { atomic_prefix, atomic_suffix });
				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0050.params(strAppendFilesKey, strT));
			}
			if (compress_files.value() == true) {
				String strT = getOptionNamesAsString(new SOSOptionElement[] { compress_files });
				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0050.params(strAppendFilesKey, strT));
			}
			if (compress_files.value() == true) {
				String strT = getOptionNamesAsString(new SOSOptionElement[] { append_files, compress_files });
				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0030.params(strT));
			}
			// TODO this check must be done at the implementation layer of the protocol-class.
			if (protocol.equalsIgnoreCase("ftp")) {
				// oke
			}
			else {
				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0040.params(strAppendFilesKey, protocol.Value()));
			}
		}
		if (this.Target().protocol.isDirty()) {
			if (protocol.isDirty() == false) {
				protocol.Value(this.Target().protocol.Value());
			}
		}
		setDefaultHostPort(protocol, port, host);
		setDefaultHostPort(this.Source().protocol, this.Source().port, this.Source().host);
		setDefaultHostPort(this.Target().protocol, this.Target().port, this.Target().host);
		setDefaultHostPort(this.Source().Alternatives().protocol, this.Source().Alternatives().port, this.Source().Alternatives().host);
		setDefaultHostPort(this.Target().Alternatives().protocol, this.Target().Alternatives().port, this.Target().Alternatives().host);
		setDefaultAuth(this.Source().protocol, this.Source());
		setDefaultAuth(this.Target().protocol, this.Target());
		setDefaultAuth(this.Source().Alternatives().protocol, this.Source().Alternatives());
		setDefaultAuth(this.Target().Alternatives().protocol, this.Target().Alternatives());
		if (file_path.isDirty()) {
			if (file_spec.isDirty()) {
				file_path.Value("");
				String strT = getOptionNamesAsString(new SOSOptionElement[] { file_path, file_spec });
//				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0030.params(strT));
			}
			if (recursive.value() == true) {
				String strT = getOptionNamesAsString(new SOSOptionElement[] { file_path, recursive });
				//				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0030.params(strT));
			}
		}
		if (file_path.IsEmpty() && file_spec.IsEmpty() && FileListName.IsEmpty()) {
			throw new JobSchedulerException(String.format("SOSVfs-E-0000: one of these parameters must be specified: '%1$s', %2$s', '%3$s'",
					file_path.getShortKey(), file_spec.getShortKey(), FileListName.getShortKey()));
		}
		getDataSourceType();
		getDataTargetType();
		if (CheckNotProcessedOptions.value() == true) {
			this.CheckNotProcessedOptions();
		}
		flgCheckMandatoryDone = true;
	} // private void CheckMandatory

	private void checkReplaceAndReplacing(final SOSConnection2OptionsSuperClass pobjO) {
		if (pobjO.replacing.IsNotEmpty() && pobjO.replacement.IsNull()) {
			pobjO.replacement.Value("");
			// throw new JobSchedulerException(String.format(objMsg.getMsg(SOSVfs_E_0020), replacing.getKey(), replacement.getKey()));
		}
		if (pobjO.replacing.IsEmpty() && pobjO.replacement.IsNotEmpty()) {
			// throw new JobSchedulerException("SOSVfs-E-0000: parameter is missing for specified parameter [replacement]: [replacing]");
			throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_0020.params(pobjO.replacement.getKey(), pobjO.replacing.getKey()));
		}
	}

	private void checkCredentialStore(final SOSConnection2OptionsAlternate pobjO) {
		if (pobjO.getCredentialStore() != null) {
			pobjO.checkCredentialStoreOptions();
		}
	}
	
	private void checkURLParameter (final SOSConnection2OptionsAlternate pobjO) {
		if (pobjO.url.isDirty()) {
			pobjO.url.getOptions(pobjO);
		}
	}

	private void setDefaultAuth(final SOSOptionTransferType pobjTransferTyp, final SOSConnection2OptionsAlternate objConn) {
		enuTransferTypes transferType = pobjTransferTyp.getEnum();
		if (transferType == enuTransferTypes.http || transferType == enuTransferTypes.https || transferType == enuTransferTypes.webdav) {
			if (!objConn.auth_method.isDirty() && !objConn.ssh_auth_method.isDirty()) {
				objConn.auth_method.Value(enuAuthenticationMethods.url);
				objConn.ssh_auth_method.Value(enuAuthenticationMethods.url);
			}
		}
	}
	
	private void setDefaultHostPort(final SOSOptionTransferType pobjTransferTyp, final SOSOptionPortNumber pobjPort, final SOSOptionHostName pobjHost) {
		enuTransferTypes transferType = pobjTransferTyp.getEnum();
		
		switch (transferType) {
		case sftp:
			pobjPort.DefaultValue("" + SOSOptionPortNumber.conPort4SFTP);
			break;
		case ftp:
			pobjPort.DefaultValue("" + SOSOptionPortNumber.conPort4FTP);
			break;
		case zip:
		case file:
		case local:
			pobjPort.DefaultValue("0");
			if (pobjHost.isNotDirty()
					|| pobjHost.Value().equalsIgnoreCase("localhost")
					|| pobjHost.Value().equalsIgnoreCase("127.0.0.1")) {
				pobjHost.Value(SOSOptionHostName.getLocalHost());
			}
			break;
		case ftps:
			pobjPort.DefaultValue("" + SOSOptionPortNumber.conPort4FTPS);
			break;
		case webdav:
		case http:
		case https:
			if (pobjHost.Value().toLowerCase().startsWith("https://")) {
				pobjPort.DefaultValue("443");
			}
			else {
				pobjPort.DefaultValue("" + SOSOptionPortNumber.conPort4http);
			}
			break;
		default:
			break;
		}
		if (pobjPort.isNotDirty()) {
			pobjPort.Value(pobjPort.DefaultValue());
			pobjPort.setNotDirty();
			pobjPort.setProtected(pobjTransferTyp.isProtected());
		}
	}

	@SuppressWarnings("unused") private boolean isSourceDirSpecified() {
		final String conMethodName = conClassName + "::isSourceDirSpecified";
		boolean flgResult = false;
		if (local_dir.IsEmpty() && SourceDir.IsEmpty() && Source().FolderName.IsEmpty()) {
			flgResult = false;
		}
		else {
			flgResult = true;
		}
		return flgResult;
	} // private boolean isSourceDirSpecified

	private String getOptionNamesAsString(final SOSOptionElement[] objA) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getOptionNamesAsString";
		String strRet = "";
		for (SOSOptionElement sosOptionElement : objA) {
			if (strRet.length() > 0) {
				strRet += ", ";
			}
			strRet += sosOptionElement.getKey() + "=" + sosOptionElement.Value();
		}
		return strRet;
	} // private String getOptionNamesAsString

	/**
	 *
	 * \brief isAtomicTransfer
	 *
	 * \details
	 *
	 * \return boolean
	 *
	 * @return
	 */
	@Override public boolean isAtomicTransfer() {
		boolean flgIsAtomicTransfer = atomic_prefix.IsNotEmpty() || atomic_suffix.IsNotEmpty();
		return flgIsAtomicTransfer;
	}

	/**
	 *
	 * \brief getEnvVars
	 *
	 * \details
	 *
	 * \return Properties
	 *
	 * @return
	 * @throws Exception
	 */
	private Properties getEnvVars() throws Exception {
		// TODO raus hier. die Routine ist zu generell und muß in die Shell-Klasse
		try {
			propSOSFtpEnvironmentVars = new Properties();
			// TODO SchedulerParams hat hier nichts zu suchen. Die müssen "von oben" über den JS-Adapter in die Klassen gereicht werden
			schedulerParams = new Properties();
			int intSOSFtpEnvVarPrefixLen = conSOSFtpEnvVarPrefix.length();
			Map<String, String> objM = System.getenv();
			propAllEnvironmentVariables = new Properties();
			propAllEnvironmentVariables.putAll(objM);
			for (Object k : propAllEnvironmentVariables.keySet()) {
				String key = (String) k;
				String value = (String) propAllEnvironmentVariables.get(k);
				//				logger.debug("getEnvVars() - " + key + "=" + value); //$NON-NLS-1$ //$NON-NLS-2$
				if (key.startsWith(conSOSFtpEnvVarPrefix)) {
					key = key.substring(intSOSFtpEnvVarPrefixLen);
					propSOSFtpEnvironmentVars.setProperty(key, value);
					continue;
				}
				if (key.startsWith("current_pid") || key.startsWith("ppid")) {
					propSOSFtpEnvironmentVars.setProperty(key, value);
					continue;
				}
				// TODO obsolet. must come from the JSAdapter as a Property-Collection
				if (key.indexOf(conSchedulerEnvVarPrefix) > -1) {
					schedulerParams.setProperty(key.substring(conSchedulerEnvVarPrefix.length()), value);
					continue;
				}
			}
			return propSOSFtpEnvironmentVars;
		}
		catch (Exception e) {
			String strM = SOSVfsMessageCodes.SOSVfs_E_161.params("reading environment", e.toString());
			logger.error(strM, e);
			throw new JobSchedulerException(strM, e);
		}
	}

	/**
	 * \brief CommandLineArgs
	 *
	 * \details
	 *
	 * \return
	 *
	 * @param pstrArgs
	 * @throws Exception
	 */
	@Override public void CommandLineArgs(final String[] pstrArgs)  {
		super.CommandLineArgs(pstrArgs);
		this.setAllOptions(super.objSettings);
		boolean flgFound = false;
		for (int i = 0; i < pstrArgs.length; i++) {
			String strParam = pstrArgs[i];
			if (strParam.toLowerCase().startsWith("-settings")) {
				pstrArgs[i] = "-ignored=ignored";
				flgFound = true;
			}
		}
		if (flgFound == true) {
			super.CommandLineArgs(pstrArgs);
		}
	}

	@Override
	public void CommandLineArgs(final String pstrArgs) {
		//TODO split(" ") is buggy, wenn der Wert einer Option ein Leerzeichen enthält.
		try {
			this.CommandLineArgs(pstrArgs.split(" "));
		}
		catch (Exception e) {
			logger.error(e.getLocalizedMessage());
			throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_153.params("command lines args"), e);
		}
	}

	/**
	 * \brief setAllOptions
	 *
	 * \details
	 *
	 * \return
	 *
	 * @param pobjJSSettings
	 * @throws Exception
	 */
	@Override public void setAllOptions(final HashMap<String, String> pobjJSSettings)  {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setAllOptions";
		flgSetAllOptions = true;
		objSettings = pobjJSSettings;
		super.Settings(objSettings);
		super.setAllOptions(pobjJSSettings);
		flgSetAllOptions = false;
		HashMap<String, String> hshMap = pobjJSSettings;
		if (flgSettingsFileProcessed == false && flgReadSettingsFileIsActive == false) {
			if (ConfigurationFile.IsNotEmpty()) {
				flgReadSettingsFileIsActive = true;
				hshMap = ReadSettingsFile();
				flgReadSettingsFileIsActive = false;
				flgSettingsFileProcessed = true;
			}
		}
		// populate all the Options for "source_" and "target_" ....
		setChildClasses(hshMap);
	} // public void setAllOptions (HashMap <String, String> JSSettings)

	/**
	 *
	 * \brief ReadSettingsFile
	 *
	 * \details
	 * The Name of the Settings-File and the Name of the Profile (Section) has to be defined by the Options
	 * "settings" and "profile" before entering this method.
	 * \return void
	 *
	 */
	// TODO move 'ReadSettingsFile' to JSOptionClass
	public HashMap<String, String> ReadSettingsFile() {
		// TODO use the virtual file-system to allow access to diffent types of setting-stores
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::ReadSettingsFile";
		settings.CheckMandatory();
		profile.CheckMandatory();
		HashMap<String, String> map = new HashMap<String, String>();
		Properties objGlobals = null;
		SOSStandardLogger objSOSLogger = null;
		SOSConfiguration objConf = null;
		Properties objP = new Properties();
		try {
			{
				objSOSLogger = new SOSStandardLogger(0);
				getEnvVars();// TODO replace SOSConfigurations by a "ini-File-only" approach, to avoid dependencies on job-scheduler
				// TODO discard ^M at the end of the line to avoid conflicts with windows -> unix-files
				objConf = new SOSConfiguration(settings.Value(), "globals", objSOSLogger);
				objGlobals = objConf.getParameterAsProperties();
				objConf = new SOSConfiguration(settings.Value(), profile.Value(), objSOSLogger);
				if (objConf.getParameterAsProperties().size() <= 0) {
					String strM = SOSVfsMessageCodes.SOSVfs_E_0060.params(profile.Value(), settings.Value());
					logger.error(strM, new JobSchedulerException(strM));
					throw new JobSchedulerException(strM);
				}
				objP.putAll(objGlobals);
				objP.putAll(objConf.getParameterAsProperties());
			}
			ResolveIncludes:
			while (true) {
				Properties objIncludes = new Properties();
				boolean flgIncludeFound = false;
				for (Object k : objP.keySet()) {
					String strKey = (String) k;
					String strValue = (String) objP.get(k);
					logger.trace("ReadSettingsFile() - Property. Key = " + strKey + ", val = " + strValue);
					if (isIncludeDirective(strKey)) {
						String[] strValues = strValue.split("[;|,]");
						String strIncludePrefix = getIncludePrefix(strKey);
						for (String strV : strValues) {
							strV = strV.trim();
							SOSConfiguration config_ = new SOSConfiguration(settings.Value(), strV, objSOSLogger);
							if (config_.getParameterAsProperties().size() <= 0) {
								String strM = SOSVfsMessageCodes.SOSVfs_E_0000.params(strV, settings.Value());
								logger.error(strM);
								throw new JobSchedulerException(strM);
							}
							objIncludes.putAll(config_.getParameterAsProperties(strIncludePrefix));
						}
						flgIncludeFound = true;
					}
					//					else {
					//						if (isIniComment(strKey) == false) {
					//							// TODO check duplicate Entry but take into account, that includes are in effect
					//							objIncludes.put(strKey, strValue);
					//						}
					//					}
				} // for
				if (objIncludes.size() > 0 && flgIncludeFound == true) {
					flgIncludeProcessingInProgress = true;
					this.setAllOptions(objIncludes);
					setChildClasses(objIncludes);
					flgIncludeProcessingInProgress = false;
					isFragment.setFalse();
					break ResolveIncludes;
				}
				else {
					break ResolveIncludes;
				}
			} // ResolveIncludes
				// Additional Variables
			objP.put("uuid", "");
			objP.put("date", SOSOptionTime.getCurrentDateAsString());
			objP.put("time", SOSOptionTime.getCurrentTimeAsString("hh:mm:ss"));
			objP.put("local_user", System.getProperty("user.name"));
			java.net.InetAddress localMachine = java.net.InetAddress.getLocalHost();
			objP.put("localhost", localMachine.getHostName());
			objP.put("local_host_ip", localMachine.getHostAddress());
			for (Object k : objP.keySet()) {
				String strKey = (String) k;
				if (strKey.equalsIgnoreCase("uuid") == true) {
					objP.put(strKey, UUID.randomUUID().toString());
				}
				String strValue = (String) objP.get(k);
				if (hasVariableToSubstitute(strValue) == true && gflgSubsituteVariables == true) {
					logger.trace("ReadSettingsFile() - Key = " + strKey + ", value = " + strValue); //$NON-NLS-1$ //$NON-NLS-2$
					strValue = SubstituteVariables(strValue, objP, "${", conVariableEND);
					strValue = SubstituteVariables(strValue, objP, "%{", conVariableEND);
					strValue = SubstituteVariables(strValue, objP, "%", "%");
					strValue = SubstituteVariables(strValue, propSOSFtpEnvironmentVars, "${", conVariableEND);
					strValue = SubstituteVariables(strValue, propSOSFtpEnvironmentVars, "%{", conVariableEND);
					strValue = SubstituteVariables(strValue, propSOSFtpEnvironmentVars, "%", "%");
					strValue = SubstituteVariables(strValue, propAllEnvironmentVariables, "${", conVariableEND);
					strValue = SubstituteVariables(strValue, propAllEnvironmentVariables, "%{", conVariableEND);
					strValue = SubstituteVariables(strValue, propAllEnvironmentVariables, "%", "%");
					// TODO wrong place: has to come from the JS-Adapter as properties
					strValue = SubstituteVariables(strValue, schedulerParams, "${", conVariableEND);
					strValue = SubstituteVariables(strValue, schedulerParams, "%{", conVariableEND);
					strValue = SubstituteVariables(strValue, schedulerParams, "%", "%");
					if (hasVariableToSubstitute(strValue)) {
						String strM = SOSVfsMessageCodes.SOSVfs_W_0070.params(strValue, strKey);
						logger.warn(strM);
					}
				}
				map.put(strKey, strValue);
			}
			super.setAllOptions(map);
			setChildClasses(map);
		}
		catch (Exception e) {
			logger.error("ReadSettingsFile()", e); //$NON-NLS-1$
			throw new JobSchedulerException(e.getMessage(), e);
		}
		return map;
	} // private void ReadSettingsFile

	private boolean hasVariableToSubstitute(final String pstrValue) {
		boolean flgResult = false;
		if (pstrValue.indexOf("${") != -1 || pstrValue.indexOf("%{") != -1) {
			flgResult = true;
		}
		return flgResult;
	}

	private boolean isIniComment(final String pstrText) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::isIniComment";
		return pstrText.trim().startsWith(";");
	} // private boolean isIniComment
	String[]	strIncludeDirectives	= new String[] { "include", "source_include", "target_include", "jump_include", "alternate_include",
			"alternatesource_include", "alternatetarget_include", "alternative_source_include", "alternative_target_include" };
	String[]	strIncludePrefixes		= new String[] { "", "source_", "target_", "jump_", "alternate_", "alternatesource_", "alternatetarget_", "alternative_source_", "alternative_target_" };

	public boolean isIncludeDirective(final String pstrText) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::isIncludeDirective";
		boolean flgR = false;
		for (String strText : strIncludeDirectives) {
			if (pstrText.equalsIgnoreCase(strText)) {
				flgR = true;
				break;
			}
		}
		return flgR;
	} // private boolean isIncludeDirective

	public String getIncludePrefix(final String pstrText) {
		String strR = "";
		int i = 0;
		for (String strText : strIncludeDirectives) {
			if (pstrText.equalsIgnoreCase(strText)) {
				strR = strIncludePrefixes[i];
				break;
			}
			i++;
		}
		return strR;
	}

	public String SubstituteVariables(String txt, final Properties prop, final String startPrefix, final String endPrefix) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::SubstituteVariables";
		try {
			for (Object k : prop.keySet()) {
				String key = (String) k;
				String strValue = (String) prop.get(key);
				String strSearchFor = startPrefix + key + endPrefix;
				// logger.debug(String.format("search for  '%1$s' with value '%2$s'", strSearchFor, strValue));
				int pos1 = -1;
				int pos2 = 0;
				while (true) {
					pos1 = txt.indexOf(strSearchFor, pos2);
					if (pos1 == -1) {
						break;
					}
					// logger.debug(String.format("found '%1$s'", strSearchFor));
					int intEscaped = txt.indexOf("\\" + strSearchFor);
					if (intEscaped > -1 && intEscaped == pos1 - 1)
						pos1 = -1;
					pos2 = pos1 + strSearchFor.length();
					if (pos1 > -1 && pos2 > pos1) {
						txt = txt.substring(0, pos1) + strValue + txt.substring(pos2);
						// logger.debug(String.format("new Text = '%1$s'", txt));
					}
				} // while
			} // for
			return txt;
		}
		catch (Exception e) {
			throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_197.params(txt), e);
		}
	}

	// TODO in die Klasse JSFile implementieren
	protected URI createURI(final String fileName) {
		URI uri = null;
		try {
			uri = new URI(fileName);
		}
		catch (Exception e) {
			try {
				File f = new File(fileName);
				String path = f.getCanonicalPath();
				if (fileName.startsWith("/")) {
					path = fileName;
				}
				String fs = System.getProperty(conSystemPropertyFILE_SEPARATOR);
				if (fs.length() == 1) {
					char sep = fs.charAt(0);
					if (sep != '/')
						path = path.replace(sep, '/');
					if (path.charAt(0) != '/')
						path = '/' + path;
				}
				if (!path.startsWith(conURIPrefixFILE)) {
					path = conURIPrefixFILE + path;
				}
				uri = new URI(path);
			}
			catch (Exception ex) {
				throw new JobSchedulerException(SOSVfsMessageCodes.SOSVfs_E_198.params(e.getMessage()));
			}
		}
		return uri;
	}

	/**
	 *
	 * \brief OneOrMoreSingleFilesSpecified
	 *
	 * \details
	 * Returns true, if one or more file-/path-names explicit specified
	 * (instead of path or RegExp).
	 *
	 * \return boolean
	 *
	 * @return
	 */
	public boolean OneOrMoreSingleFilesSpecified() {
		boolean flgOneOrMoreSingleFilesSpecified = file_path.IsNotEmpty() || FileListName.IsNotEmpty();
		return flgOneOrMoreSingleFilesSpecified;
	}

	/**
	 *
	 * \brief getDataTargetType
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @return
	 */
	public String getDataTargetType() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getDataTargetType";
		String strDataTargetType = "";
		if (operation.Value().equalsIgnoreCase(conOperationSEND)) {
			strDataTargetType = protocol.Value();
			if (strDataTargetType.length() <= 0) {
				strDataTargetType = enuTransferTypes.local.Text();
			}
			CopyValue(SourceDir, local_dir);
			CopyValue(TargetDir, remote_dir);
			CopyValue(this.Source().Directory, local_dir);
			CopyValue(this.Target().Directory, remote_dir);
			changeOptions(this.getConnectionOptions().Target());
		}
		else {
			if (operation.Value().equalsIgnoreCase(conOperationRECEIVE)) {
				strDataTargetType = enuTransferTypes.local.Text(); // "local";
				CopyValue(SourceDir, remote_dir);
				CopyValue(TargetDir, local_dir);
				CopyValue(this.Source().Directory, remote_dir);
				CopyValue(this.Target().Directory, local_dir);
				changeOptions2Local(this.getConnectionOptions().Target());
			}
			else {
				strDataTargetType = this.getConnectionOptions().Target().protocol.Value();
				if (strDataTargetType.length() <= 0) {
					strDataTargetType = enuTransferTypes.local.Text();
				}
				changeDirValues();
			}
		}
		logger.debug(SOSVfsMessageCodes.SOSVfs_D_262.params(strDataTargetType));
		return strDataTargetType;
	} // private String getDataTargetType

	private void changeOptions(final SOSConnection2OptionsAlternate objT) {
		objT.host.Set(host);
		logger.debug("prefix_host = " + objT.host.Value());
		objT.user.Value(user.Value());
		objT.password.Set(password);
		objT.port.Set(port);
		objT.protocol.Set(protocol);
		objT.passive_mode.Set(passive_mode);
		objT.transfer_mode.Set(transfer_mode);
		objT.ssh_auth_file.SetIfNotDirty(ssh_auth_file);
		objT.ssh_auth_method.SetIfNotDirty(ssh_auth_method);
		SOSConnection2OptionsSuperClass objAlt = objT.Alternatives();
		objAlt.host.Value(alternative_host.Value());
		objAlt.port.value(alternative_port.value());
		objAlt.protocol.Value(protocol.Value());
		objAlt.passive_mode.Value(alternative_passive_mode.Value());
		objAlt.transfer_mode.Value(alternative_transfer_mode.Value());
		//		objT.loadClassName.Value(loadClassName.Value());
	}

	private void changeOptions2Local(final SOSConnection2OptionsAlternate objT) {
		objT.host.Value("localhost");
		logger.debug("prefix_host = " + objT.host.Value());
		objT.user.Value("");
		objT.password.Value("");
		objT.port.value(0);
		objT.protocol.Value("local");
		objT.passive_mode.Value("");
		objT.transfer_mode.Value("");
		SOSConnection2OptionsSuperClass objAlt = objT.Alternatives();
		objAlt.host.Value("localhost");
		objAlt.port.value(0);
		objAlt.protocol.Value("local");
		objAlt.passive_mode.Value("");
		objAlt.transfer_mode.Value("");
		//		objT.loadClassName.Value(loadClassName.Value());
	}

	private void CopyValue(final SOSOptionElement objTo, final SOSOptionElement objFrom) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::CopyValue";
		if (objTo.isNotDirty()) {
			objTo.Value(objFrom.Value());
		}
	} // private void CopyValue

	/**
	 *
	 * \brief getDataSourceType
	 *
	 * \details
	 *
	 * \return String
	 *
	 * @return
	 */
	public String getDataSourceType() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getDataSourceType";
		String strDataSourceType = "";
		if (operation.Value().equalsIgnoreCase(conOperationSEND)) {
			strDataSourceType = enuTransferTypes.local.Text();
			changeDirValues();
			// if (this.getConnectionOptions().Source().protocol.IsNotEmpty()) {
			// strDataSourceType = this.getConnectionOptions().Source().protocol.Value();
			// }
			SOSConnection2OptionsAlternate objT = this.getConnectionOptions().Source();
			objT.host.Value(SOSOptionHostName.conLocalHostName);
			objT.port.value(0);
			objT.protocol.Value(strDataSourceType);
			objT.user = user;
			objT.password = password;
			objT.ssh_auth_file = ssh_auth_file;
			objT.ssh_auth_method = ssh_auth_method;
			objT.passive_mode = passive_mode;
			objT = this.getConnectionOptions().Target();
			objT.host = host;
			objT.port = port;
			objT.protocol = protocol;
			objT.user = user;
			objT.password = password;
			objT.ssh_auth_file = ssh_auth_file;
			objT.ssh_auth_method = ssh_auth_method;
			objT.passive_mode = passive_mode;
			SOSConnection2OptionsSuperClass objAlt = objT.Alternatives();
			objAlt.host.Value(alternative_host.Value());
			objAlt.port.value(alternative_port.value());
			objAlt.protocol.Value(protocol.Value());
			objAlt.passive_mode.Value(alternative_passive_mode.Value());
		}
		else {
			if (operation.Value().equalsIgnoreCase(conOperationRECEIVE)) {
				strDataSourceType = protocol.Value();
				if (strDataSourceType.length() <= 0) {
					strDataSourceType = enuTransferTypes.local.Text();
				}
				changeDirValues4Receive();
				SOSConnection2OptionsAlternate objT = this.getConnectionOptions().Source();
				objT.host.Value(host.Value());
				objT.port.value(port.value());
				objT.protocol.Value(protocol.Value());
				objT.passive_mode.Value(passive_mode.Value());
				objT.user = user;
				objT.password = password;
				objT.ssh_auth_file = ssh_auth_file;
				objT.ssh_auth_method = ssh_auth_method;
				SOSConnection2OptionsSuperClass objAlt = objT.Alternatives();
				objAlt.host.Value(alternative_host.Value());
				objAlt.port.value(alternative_port.value());
				objAlt.protocol.Value(protocol.Value());
				objAlt.passive_mode.Value(alternative_passive_mode.Value());
			}
			else {
				strDataSourceType = this.getConnectionOptions().Source().protocol.Value();
				if (strDataSourceType.length() <= 0) {
					strDataSourceType = enuTransferTypes.local.Text();
				}
				changeDirValues();
			}
		}
		logger.debug(SOSVfsMessageCodes.SOSVfs_D_199.params(strDataSourceType));
		return strDataSourceType;
	} // private String getDataSourceType

	@SuppressWarnings("unused") private void ReplicateConnectionOptions(SOSConnection2OptionsAlternate objT) {
		final String conMethodName = conClassName + "::ReplicateConnectionOptions";
		objT.host.Value(SOSOptionHostName.conLocalHostName);
		objT.port.value(0);
		objT.protocol.Value(enuTransferTypes.local.Text());
		objT = this.getConnectionOptions().Target();
		objT.host = host;
		objT.port = port;
		objT.protocol = protocol;
		objT.user = user;
		objT.password = password;
		objT.ssh_auth_file = ssh_auth_file;
		objT.ssh_auth_method = ssh_auth_method;
		objT.passive_mode = passive_mode;
	} // private void ReplicateConnectionOptions

	private void changeDirValues() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::changeDirValues";
		ChangeValue(SourceDir, local_dir);
		ChangeValue(TargetDir, remote_dir);
		ChangeValue(local_dir, SourceDir);
		ChangeValue(remote_dir, TargetDir);
		ChangeValue(Source().FolderName, SourceDir);
		ChangeValue(Target().FolderName, TargetDir);
	} // private void changeDirValues

	private void changeDirValues4Receive() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::changeDirValues";
		ChangeValue(SourceDir, remote_dir);
		ChangeValue(TargetDir, local_dir);
	} // private void changeDirValues

	private void ChangeValue(final SOSOptionElement pobjTarget, final SOSOptionElement pobjSource) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::ChangeValue";
		if (pobjTarget.IsEmpty() == true /* && pobjTarget.isDirty() == false */) {
			if (pobjSource.IsEmpty() == false) {
				logger.trace(SOSVfsMessageCodes.SOSVfs_I_263.params(pobjTarget.getKey(), pobjSource.Value()));
				pobjTarget.Set(pobjSource);
			}
		}
	} // private void ChangeValue

	/**
	 *
	 * \brief DoNotOverwrite
	 *
	 * \details
	 *
	 * \return boolean
	 *
	 * @return
	 */
	public boolean DoNotOverwrite() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::DoNotOverwrite";
		boolean flgT = overwrite_files.value() == false && append_files.value() == false;
		return flgT;
	} // private boolean DoNotOverwrite


	/**
	 * \brief getconnectionOptions
	 *
	 * \details
	 * getter
	 *
	 * @return the connectionOptions
	 */
	public SOSConnection2Options getConnectionOptions() {
		if (objConnectionOptions == null) {
			objConnectionOptions = new SOSConnection2Options();
		}
		return objConnectionOptions;
	}

	/**
	 * \brief setconnectionOptions -
	 *
	 * \details
	 * setter
	 *
	 * @param connectionOptions the value for connectionOptions to set
	 */
	public void setConnectionOptions(final SOSConnection2Options connectionOptions) {
		objConnectionOptions = connectionOptions;
	}

	public boolean isReplaceReplacingInEffect() {
		boolean flgRC = false;
		flgRC = this.getreplacing().IsNotEmpty();
		return flgRC;
	}

	public SOSConnection2OptionsAlternate Source() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::Source";
		return getConnectionOptions().Source();
	} // private SOSConnection2OptionsAlternate Source

	public SOSConnection2OptionsAlternate Target() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::Source";
		return getConnectionOptions().Target();
	} // private SOSConnection2OptionsAlternate Source

	public boolean NeedTargetClient() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::NeedTargetClient";
		boolean flgNeedTargetClient = true;
		switch (operation.value()) {
			case delete:
			case getlist:
			case rename:
				flgNeedTargetClient = false;
				break;
			default:
				break;
		}
		return flgNeedTargetClient;
	} // private boolean NeedTargetClient

	public SOSFTPOptions getClone() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getClone";
		SOSFTPOptions objClone = new SOSFTPOptions();
		String strB = this.getOptionsAsCommandLine();
		objClone.CommandLineArgs(strB);
		return objClone;
	} // private SOSFTPOptions getClone

	public void ClearJumpParameter() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::ClearJumpParameter";
		String strNullString = null;
		jump_user.Value(strNullString);
		jump_password.Value(strNullString);
		jump_protocol.Value(strNullString);
		jump_host.Value(strNullString);
		jump_ssh_auth_method.Value(strNullString);
		jump_command.Value(strNullString);
		host.Value(strNullString);
	} // private void ClearJumpParameter

	public boolean isFilePollingEnabled() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::isFilePollingEnabled";
		boolean flgFilePollingEnabled = false;
		if ((poll_timeout.isDirty() || PollingDuration.isDirty()) && skip_transfer.isFalse()) {
			flgFilePollingEnabled = true;
		}
		return flgFilePollingEnabled;
	} // private boolean isFilePollingEnabled

	public String DirtyString() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::DirtyString";
		String strD = "\n" + super.dirtyString();
		strD += "\n" + Source().dirtyString();
		strD += "\n" + Target().dirtyString();
		return strD;
	} // private String DirtyString

	@Override public SOSOptionRegExp getreplacing() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getreplacing";
		SOSOptionRegExp objR = super.getreplacing();
		if (Target().getreplacing().isDirty()) {
			objR = Target().getreplacing();
		}
		return objR;
	} // private SOSOptionRegExp getreplacing

	@Override public SOSOptionString getreplacement() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getreplacement";
		SOSOptionString objR = super.getreplacement();
		if (Target().getreplacement().isDirty()) {
			objR = Target().getreplacement();
		}
		return objR;
	} // private SOSOptionRegExp getreplacement
}
