package com.sos.VirtualFileSystem.DataElements;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Date;
import java.util.HashMap;
import java.util.Properties;
import java.util.UUID;

import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.util.Base64;
import org.apache.log4j.Logger;

import com.sos.JSHelper.Exceptions.JobSchedulerException;
import com.sos.JSHelper.Options.SOSOptionString;
import com.sos.JSHelper.Options.SOSOptionTime;
import com.sos.JSHelper.interfaces.ISOSFtpOptions;
import com.sos.JSHelper.io.Files.JSTextFile;
import com.sos.VirtualFileSystem.Factory.VFSFactory;
import com.sos.VirtualFileSystem.Interfaces.IJadeTransferDetailHistoryData;
import com.sos.VirtualFileSystem.Interfaces.ISOSVfsFileTransfer;
import com.sos.VirtualFileSystem.Interfaces.ISOSVirtualFile;
import com.sos.VirtualFileSystem.Options.SOSConnection2Options;
import com.sos.VirtualFileSystem.Options.SOSConnection2OptionsAlternate;
import com.sos.VirtualFileSystem.Options.SOSFTPOptions;
import com.sos.VirtualFileSystem.common.SOSVfsConstants;
import com.sos.VirtualFileSystem.common.SOSVfsMessageCodes;
import com.sos.VirtualFileSystem.zip.SOSVfsZip;
import com.sos.i18n.annotation.I18NResourceBundle;

/**
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
APL/Software GmbH - Berlin
##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
Montag, 15. Oktober 2007, Klaus.Buettner@sos-berlin.com (KB)
* <br />---------------------------------------------------------------------------
* </p>
* SOSFileListEntry - Datenstruktur für Dateiverarbeitung
* <p>
* Diese Klasse reprüsentiert eine Datenstruktur für die Dateiverarbeitung
* von lokalen und remote Dateien.
* </p>
* <p>
* Verwendung findet diese Struktur beim download von Dateien, deren Name
* über einen (regulüren) Ausdruck definiert ist und dabei dann mehr als
* eine Datei relevant ist.
* </p>
* @author Klaus.Buettner@sos-berlin.com
* @version $Id$ 0.9
* @see reference
* @exception classname description
*
*/
@I18NResourceBundle(
					baseName = "SOSVirtualFileSystem",
					defaultLocale = "en")
public class SOSFileListEntry extends SOSVfsMessageCodes implements Runnable, IJadeTransferDetailHistoryData /* , ISOSVirtualFile */{
	private static final String	conFieldJUMP_USER			= "jump_user";
	private static final String	conFieldJUMP_PROTOCOL		= "jump_protocol";
	private static final String	conFieldJUMP_PORT			= "jump_port";
	private static final String	conFieldJUMP_HOST_IP		= "jump_host_ip";
	private static final String	conFieldJUMP_HOST			= "jump_host";
	private static final String	conFieldLOG_FILENAME		= "log_filename";
	private static final String	conFieldLAST_ERROR_MESSAGE	= "last_error_message";
	private static final String	conFieldSTATUS				= "status";
	private static final String	conFieldMD5					= "md5";
	private static final String	conFieldFILE_SIZE			= "file_size";
	private static final String	conFieldREMOTE_FILENAME		= "remote_filename";
	private static final String	conFieldLOCAL_FILENAME		= "local_filename";
	private static final String	conFieldREMOTE_DIR			= "remote_dir";
	private static final String	conFieldLOCAL_DIR			= "local_dir";
	private static final String	conFieldPORT				= "port";
	private static final String	conFieldPROTOCOL			= "protocol";
	private static final String	conFieldREMOTE_USER			= "remote_user";
	private static final String	conFieldREMOTE_HOST_IP		= "remote_host_ip";
	private static final String	conFieldREMOTE_HOST			= "remote_host";
	private static final String	conFieldLOCAL_USER			= "local_user";
	private static final String	conFieldLOCALHOST_IP		= "localhost_ip";
	private static final String	conFieldLOCALHOST			= "localhost";
	private static final String	conFieldOPERATION			= "operation";
	private static final String	conFieldPPID				= "ppid";
	private static final String	conFieldPID					= "pid";
	private static final String	conFieldTRANSFER_TIMESTAMP	= "transfer_timestamp";
	private static final String	conFieldMANDATOR			= "mandator";
	private static final String	conFieldGUID				= "guid";
	public enum enuTransferStatus {
		transferUndefined, waiting4transfer, transferring, transferInProgress, transferred, transfer_skipped, transfer_has_errors, transfer_aborted, compressed, notOverwritten, deleted, renamed, IgnoredDueToZerobyteConstraint, setBack, polling
	}
	private static String			conClassName					= "SOSFileListEntry";
	private final static Logger		logger							= Logger.getLogger(SOSFileListEntry.class);
	private final static Logger		objJadeReportLogger				= Logger.getLogger(VFSFactory.getLoggerName());
	@SuppressWarnings("unused")
	private final String			conSVNVersion					= "$Id$";
	//	private static boolean									flgNoDataSent					= false;
	private ISOSVirtualFile			fleSourceTransferFile			= null;
	private ISOSVirtualFile			fleSourceFile					= null;
	private ISOSVirtualFile			fleTargetFile					= null;
	private String					strSourceFileName				= null;
	private String					strSourceTransferName			= null;
	private String					strTargetTransferName			= null;
	private String					strTargetFileName				= null;
	private long					lngNoOfBytesTransferred			= 0;
	private long					lngFileSize						= -1L;
	private long					lastCheckedFileSize			    = -1L;
	private long					lngFileModDate					= -1L;
	private final String			strZipFileName					= "";
	private long					lngTransferProgress				= 0;
	private boolean					flgTransactionalRemoteFile		= false;
	private boolean					flgTransactionalLocalFile		= false;
	public long						zeroByteCount					= 0;
	private long					lngOriginalFileSize				= 0;
	@SuppressWarnings("unused")
	private final boolean			flgTransferSkipped				= false;
	private SOSFTPOptions			objOptions						= null;
	private String					strAtomicFileName				= EMPTY_STRING;
	private enuTransferStatus		eTransferStatus					= enuTransferStatus.transferUndefined;
	private ISOSVfsFileTransfer		objDataSourceClient				= null;
	private ISOSVfsFileTransfer		objDataTargetClient				= null;
	private ISOSVirtualFile			objTargetTransferFile			= null;
	private ISOSVirtualFile			objSourceTransferFile			= null;
	private SOSFileList				objParent						= null;
	private boolean					flgFileExists					= false;
	private String					strMD5Hash						= "n.a.";
	private Date					dteStartTransfer				= null;
	private Date					dteEndTransfer					= null;
	@SuppressWarnings("unused")
	private ISOSVfsFileTransfer		objVfsHandler					= null;
	// Hier bereits zuweisen, damit in der CSV-Datei und in der Order eine identische GUID verwendet wird.
	private final String			guid							= UUID.randomUUID().toString();
	private boolean					flgSteadyFlag					= false;
	private final boolean			flgTransferHistoryAlreadySent	= false;
	private boolean					targetFileAlreadyExists			= false;
	public boolean					flgIsHashFile					= false;
	private FTPFile					objFTPFile						= null;
	private String					strCSVRec						= new String();
	private String					strRenamedSourceFileName		= null;
	private SOSVfsConnectionPool	objConnPoolSource				= null;
	private SOSVfsConnectionPool	objConnPoolTarget				= null;

	public SOSFileListEntry() {
		super(SOSVfsConstants.strBundleBaseName);
	}

	public SOSFileListEntry(final FTPFile pobjFTPFile) {
		this();
		lngFileModDate = pobjFTPFile.getTimestamp().getTimeInMillis();
		strSourceFileName = pobjFTPFile.getName(); // Achtung: kommt fast immer als name ohne pfad
		lngFileSize = pobjFTPFile.getSize();
		lngOriginalFileSize = lngFileSize;
		objFTPFile = pobjFTPFile;
	}

	public SOSFileListEntry(final String pstrLocalFileName) {
		this("", pstrLocalFileName, 0);
	}

	public SOSFileListEntry(final String pstrRemoteFileName, final String pstrLocalFileName, final long plngNoOfBytesTransferred) {
		super(SOSVfsConstants.strBundleBaseName);
		strTargetFileName = pstrRemoteFileName;
		strSourceFileName = pstrLocalFileName;
		lngNoOfBytesTransferred = plngNoOfBytesTransferred;
		// this.setStatus(enuTransfesrStatus.waiting4transfer);
	}

	private void addCSv(final String... pstrVal) {
		for (String string : pstrVal) {
			if (strCSVRec.length() > 0) {
				strCSVRec += ";";
			}
			strCSVRec += string;
		}
	}

	private String changeBackslashes(final String pstrV) {
		return pstrV.replaceAll("\\\\", "/");
	}

	/**
	 * Diese Routine prüft *nur* auf dem lokalen fileSystem und ist aus der "Send"-Klasse kopiert.
	 * hier hat sie nichts zu suchen, da das polling für dateien in der Engine erfolgen muss,
	 * unabhüngig davon, wo die Dateien liegen. Es muü *immer* die Datasource gepollt werden.
	 *
	 * Auf alle Fülle muü hier über das Vfs auf die Datei(en) zugegriffen werden.
	 */
	public boolean CheckFileSizeIsChanging() throws Exception {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::polling";
		String lastmd5file = "";
		String message = "";
		try {
			// TODO eigentlich ist das hier "check_steady_state"
			String fileName = strSourceFileName;
			//			if (objOptions.poll_timeout.value() > 0 && isNotEmpty(fileName)) {
			//				setStatus(enuTransferStatus.polling);
			//				double delay = objOptions.poll_interval.value();
			//				double nrOfTries = (objOptions.poll_timeout.value() * 60) / delay;
			//				int tries = 0;
			//				boolean found = true;
			//				logger.info(SOSVfs_I_222.params(fileName));
			//				// TODO in die Implementation des ISOSVirtualFile verschieben
			//				File fleFile = new File(fileName);
			//				// TODO über Option auf FileSize ausweichen, da MD5 bei groüen dateien eine ziemliche Last erzeugt
			//				lastmd5file = sos.util.SOSCrypt.MD5encrypt(fleFile);
			//				Thread.sleep((long) delay * 1000);
			//				for (int i = 0; i < nrOfTries; i++) {
			//					tries++;
			//					String newMD5File = sos.util.SOSCrypt.MD5encrypt(fleFile);
			//					logger.debug(SOSVfs_D_223.params(i, newMD5File));
			//					if (!lastmd5file.equals(newMD5File)) {
			//						lastmd5file = newMD5File;
			//						logger.info(SOSVfs_I_222.params(fileName));
			//						Thread.sleep((long) delay * 1000);
			//						if (i + 1 == nrOfTries) {
			//							found = false;
			//							message = message + " " + fileName;
			//						}
			//					}
			//					else {
			//						break;
			//					}
			//				}
			//				if (found == false) {
			//					message = SOSVfs_E_224.params(objOptions.poll_timeout.value(), message);
			//					if (objOptions.force_files.value() == true) {
			//						logger.error(message);
			//						throw new JobSchedulerException(message);
			//					}
			//					else {
			//						logger.info(message);
			//						return false;
			//					}
			//				}
			//			}
			return true;
		}
		catch (Exception e) {
			throw new JobSchedulerException(SOSVfs_E_225.params(conMethodName, e));
		}
	}

	public void DeleteSourceFile() {
		// SOSFTP-152: allow source file deletion even if the filename is changed by (replace/replacing)
		String strFile2Delete = strSourceFileName;
		if (strRenamedSourceFileName != null) {
			strFile2Delete = strRenamedSourceFileName;
		}
		objDataSourceClient.getFileHandle(strFile2Delete).delete();
		String strM = SOSVfs_I_0113.params(strFile2Delete);
		logger.info(strM);
		objJadeReportLogger.info(strM);
	}

	private boolean doTransfer(final ISOSVirtualFile objInput, final ISOSVirtualFile objOutput) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::doTransfer";
		boolean flgClosingDone = false;
		if (objOutput == null) {
			RaiseException(SOSVfs_E_273.params("Target"));
		}
		if (objInput == null) {
			RaiseException(SOSVfs_E_273.params("Source"));
		}
		boolean flgCreateSecurityHash = objOptions.CreateSecurityHash.value() && flgIsHashFile == false;
		MessageDigest md = null;
		if (flgCreateSecurityHash) {
			try {
				// TODO implement in value-method of securityhashtype
				md = MessageDigest.getInstance(objOptions.SecurityHashType.Value());
			}
			catch (NoSuchAlgorithmException e1) {
				logger.error(e1.getLocalizedMessage(), e1);
				flgCreateSecurityHash = false;
			}
		}
		executePreCommands();
		long lngTotalBytesTransferred = 0;
		Base64 objBase64 = null;
		this.setStatus(enuTransferStatus.transferring);
		try {
			int intCumulativeFileSeperatorLength = 0;
			int lngBufferSize = objOptions.BufferSize.value();
			byte[] buffer = new byte[lngBufferSize];
			int intBytesTransferred;
			int intOffset = 0;
			boolean flgBase64EncodingOnOutput = false;
			boolean flgBase64EncodingOnInput = false;
			if (flgBase64EncodingOnOutput) {
				objBase64 = new Base64();
			}
			synchronized (this) {
				if (objOptions.CumulateFiles.isTrue() && objOptions.CumulativeFileSeparator.IsNotEmpty()) {
					String strFS = objOptions.CumulativeFileSeparator.Value();
					strFS = this.replaceVariables(strFS) + System.getProperty("line.separator");
					byte[] bteB = strFS.getBytes();
					intCumulativeFileSeperatorLength = bteB.length;
					objOutput.write(bteB);
				}
				if (objInput.getFileSize() <= 0) {
					objOutput.write(buffer, 0, 0);
				}
				else {
					// TODO Option Blockmode=true (default), if false line mode and getLine
					while ((intBytesTransferred = objInput.read(buffer)) != -1) {
						try {
							int intBytes2Write = intBytesTransferred;
							if (flgBase64EncodingOnOutput) {
								byte[] bteIn = new byte[intBytesTransferred];
								byte[] bteOut = objBase64.encode(bteIn);
								intBytes2Write = bteOut.length;
								buffer = bteOut;
							}
							// TODO Filter Module  "write (byte[] bteBuffer, int intOffset, int intLength )", "read (byte[] btebuffer)", Options
							objOutput.write(buffer, 0, intBytes2Write);
						}
						catch (JobSchedulerException e) {
							logger.error(e.getMessage());
							break;
						}
						// TODO in case of wrong outputbuffer the handling of the error must be improved
						lngTotalBytesTransferred += intBytesTransferred;
						// intOffset += lngTotalBytesTransferred;
						setTransferProgress(lngTotalBytesTransferred);
						if (flgCreateSecurityHash) {
							md.update(buffer, 0, intBytesTransferred);
						}
					}
				}
			}
			objInput.closeInput();
			objOutput.closeOutput();
			flgClosingDone = true;
			// objDataTargetClient.CompletePendingCommand();
			if (objDataTargetClient.isNegativeCommandCompletion()) {
				RaiseException(SOSVfs_E_175.params(objTargetTransferFile.getName(), objDataTargetClient.getReplyString()));
			}
			if (flgCreateSecurityHash) {
				strMD5Hash = toHexString(md.digest());
				logger.debug(SOSVfs_I_274.params(strMD5Hash, strSourceTransferName, objOptions.SecurityHashType.Value()));
				if (objOptions.CreateSecurityHashFile.isTrue()) {
					JSTextFile objF = new JSTextFile(strSourceFileName + "." + objOptions.SecurityHashType.Value());
					objF.WriteLine(strMD5Hash);
					objF.close();
					objF.deleteOnExit();
				}
			}
			this.setNoOfBytesTransferred(lngTotalBytesTransferred);
			lngTotalBytesTransferred += intCumulativeFileSeperatorLength;
			executeTFNPostCommnands();
			return true;
		}
		catch (JobSchedulerException e) {
			throw e;
		}
		catch (Exception e) {
			//String strT = SOSVfs_E_229.params(e);
			// TODO rollback?
			//logger.error(strT);
			throw new JobSchedulerException(e);
			//return false;
		}
		finally {
			if (flgClosingDone == false) {
				objInput.closeInput();
				objOutput.closeOutput();
				flgClosingDone = true;
			}
		}
	} //doTransfer

	private void executeCommands(final ISOSVfsFileTransfer pobjDataClient, final SOSOptionString pstrCommandString) {
		final String conMethodName = conClassName + "::executeCommands";
		if (pstrCommandString.IsNotEmpty()) {
			String strT = pstrCommandString.Value();
			strT = replaceVariables(strT);
			String strM = SOSVfs_D_0151.params(strT);
			logger.debug(strM);
			String[] strA = strT.split(";");
			for (String strCmd : strA) {
				try {
					pobjDataClient.getHandler().ExecuteCommand(strCmd);
				}
				catch (Exception e) {
					logger.error(e.getLocalizedMessage());
					throw new JobSchedulerException(conMethodName, e);
				}
			}
		}
	} // private void executeCommands

	public void executeTFNPostCommnands() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::executeTFNPostCommnands";
		executeCommands(objDataTargetClient, objOptions.TFN_Post_Command);
		executeCommands(objDataSourceClient, objOptions.getConnectionOptions().Source().TFN_Post_Command);
		executeCommands(objDataTargetClient, objOptions.getConnectionOptions().Target().TFN_Post_Command);
		//	return void;
	} // private void executeTFNPostCommnands

	public void executePostCommands() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::executePostCommands";
		executeCommands(objDataTargetClient, objOptions.Post_Command);
		executeCommands(objDataSourceClient, objOptions.getConnectionOptions().Source().Post_Command);
		executeCommands(objDataTargetClient, objOptions.getConnectionOptions().Target().Post_Command);
	} // private void executePostCommands

	private void executePreCommands() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::executePreCommands";
		executeCommands(objDataTargetClient, objOptions.Pre_Command);
		executeCommands(objDataSourceClient, objOptions.getConnectionOptions().Source().Pre_Command);
		executeCommands(objDataTargetClient, objOptions.getConnectionOptions().Target().Pre_Command);
	} // private void executePreCommands

	public boolean FileExists() {
		ISOSVirtualFile objTargetFile = objDataTargetClient.getFileHandle(MakeFullPathName(objOptions.TargetDir.Value(), strTargetFileName));
		try {
			flgFileExists = objTargetFile.FileExists();
		}
		catch (Exception e) {
			flgFileExists = false;
		}
		return flgFileExists;
	}

	public String getAtomicFileName() {
		return strAtomicFileName;
	}

	@Override public String getCommand() {
		return EMPTY_STRING;
	}

	@Override public Integer getCommandType() {
		return 0;
	}

	@Override public Date getCreated() {
		return null;
	}

	@Override public String getCreatedBy() {
		return EMPTY_STRING;
	}

	/**
	 * \brief getobjDataSourceClient
	 *
	 * \details
	 * getter
	 *
	 * @return the objDataSourceClient
	 */
	public ISOSVfsFileTransfer getDataSourceClient() {
		return objDataSourceClient;
	}

	/**
	 * \brief getobjDataTargetClient
	 *
	 * \details
	 * getter
	 *
	 * @return the objDataTargetClient
	 */
	public ISOSVfsFileTransfer getDataTargetClient() {
		return objDataTargetClient;
	}

	@Override public Date getEndTime() {
		return dteEndTransfer;
	}

	public String getFileName4ResultList() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getFileName4ResultList";
		// starting with TargetfileName.
		String strT = strTargetFileName;
		if (isEmpty(strT)) { // If empty, e.g. in case of operation getlist, use source file name
			strT = strSourceFileName;
		}
		return strT;
	} // private String getFileName4ResultList

	private String getFileNameWithoutPath(final String pstrTargetFileName) {
		String strT = adjustFileSeparator(pstrTargetFileName);
		File fleT = new File(strT);
		strT = fleT.getName();
		return strT;
	}

	@Override public Long getFileSize() {
		return lngFileSize;
	}
	
	public Long getLastCheckedFileSize() {
		return lastCheckedFileSize;
	}
	
	public void setLastCheckedFileSize(Long fileSize) {
		lastCheckedFileSize = fileSize;
	}

	@Override public String getLastErrorMessage() {
		return EMPTY_STRING;
	}

	@Override public String getMd5() {
		return strMD5Hash;
	}

	@Override public Date getModified() {
		return null;
	}

	@Override public String getModifiedBy() {
		return EMPTY_STRING;
	}

	private String getPathWithoutFileName(final String pstrTargetFileName) {
		String strT = adjustFileSeparator(pstrTargetFileName);
		File fleT = new File(strT);
		strT = fleT.getParent();
		if (strT == null) {
			strT = "/";
		}
		return adjustFileSeparator(strT);
	}

	@Override public String getPid() {
		return objOptions.getPid();
	}

	//	private final String	historyFields	= "guid;mandator;transfer_timestamp;pid;ppid;operation;localhost;localhost_ip;local_user;remote_host;remote_host_ip;remote_user;protocol;port;local_dir;remote_dir;local_filename;remote_filename;file_size;md5;status;last_error_message;log_filename";
	@Override public String getSizeValue() {
		return "";
	}

	@Override public String getSourceFilename() {
		return strSourceFileName;
	}

	@Override public Date getStartTime() {
		return dteStartTransfer;
	}

	@Override public Integer getStatus() {
		return new Integer(eTransferStatus.ordinal());
	}

	@Override public String getStatusText() {
		return eTransferStatus.name();
	}

	public ISOSVirtualFile getTargetFile(final ISOSFtpOptions objO) {
		fleSourceTransferFile = null;
		fleSourceFile = objDataSourceClient.getFileHandle(strSourceFileName);
		fleTargetFile = null;
		// first assumption: localfilename and localTransferfileName are identical
		strSourceTransferName = fleSourceFile.getName();
		// second assumption: localfilename and TargetFileName are equal (until it changed)
		strTargetFileName = fleSourceFile.getName();
		boolean flgIncludeSubdirectories = objOptions.recursive.value();
		if (objO.getcompress_files().isTrue()) { // compress file before sending
			strSourceTransferName = fleSourceFile.MakeZIPFile(objO.getcompressed_file_extension().Value());
			strTargetFileName = strTargetFileName + objO.getcompressed_file_extension().Value();
		}
		if (objOptions.CumulateFiles.isTrue()) {
			strTargetFileName = objOptions.CumulativeFileName.Value();
			strTargetTransferName = strTargetFileName;
			objOptions.append_files.value(true);
			//			if (objOptions.CumulativeFileDelete.isTrue()) {
			//			}
		}
		else {
			strTargetFileName = getFileNameWithoutPath(strTargetFileName);
			strTargetTransferName = strTargetFileName;
			// replacing has to be taken from general or target_ options for the target replacing  SOSFTP-151
			if (objO.getreplacing().IsNotEmpty()) {
				try {
					strTargetFileName = objO.getreplacing().doReplace(strTargetFileName, objO.getreplacement().Value());
				}
				catch (Exception e) {
					String strM = SOSVfs_E_0150.get();
					logger.error(e.getLocalizedMessage(), new JobSchedulerException(strM, e));
					throw new JobSchedulerException(strM, e);
				}
			}
		}
		// Atomic-Suffix and/or atomic-prefix for cumulative_file was not used
		// http://www.sos-berlin.com/jira/browse/SOSFTP-142
		if (objOptions.isAtomicTransfer() || objOptions.TransactionMode.isTrue()) {
			setTransactionalRemoteFile();
			strTargetTransferName = MakeAtomicFileName(objOptions);
		}
		if (flgIncludeSubdirectories == true) {
			String strSourceDir = getPathWithoutFileName(fleSourceFile.getName());
			String strOrigSourceDir = objO.SourceDir().Value();
			if (!fileNamesAreEqual(strSourceDir, strOrigSourceDir, true)) {
				if (strSourceDir.length() > strOrigSourceDir.length()) {
					String strSubFolder = strSourceDir.substring(strOrigSourceDir.length());
					strSubFolder = adjustFileSeparator(addFileSeparator(strSubFolder));
					strTargetFileName = strSubFolder + strTargetFileName;
					strTargetTransferName = strSubFolder + strTargetTransferName;
					if (isNotEmpty(this.getAtomicFileName())) {
						this.setAtomicFileName(strTargetTransferName);
					}
					try {
						if (objParent.add2SubFolders(strSubFolder) == true) {
							objDataTargetClient.mkdir(addFileSeparator(objO.TargetDir().Value()) + strSubFolder);
						}
					}
					catch (IOException e) {
						throw new JobSchedulerException(e);
					}
				}
			}
		}
		return null;
	}

	@Override public String getTargetFilename() {
		return strTargetFileName;
	}

	public String getTargetFileNameAndPath() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getTargetFileNameAndPath";
		String strT = objOptions.TargetDir.Value() + strTargetFileName;
		return strT;
		//	return String;
	} // private String getTargetFileNameAndPath

	public boolean getTransactionalLocalFile() {
		return flgTransactionalLocalFile;
	}

	@Override public Integer getTransferDetailsId() {
		return null;
	}

	@Override public Integer getTransferId() {
		return null;
	}

	/**
	 * \brief getlngTransferProgress
	 *
	 * \details
	 * getter
	 *
	 * @return the lngTransferProgress
	 */
	public long getTransferProgress() {
		return lngTransferProgress;
	}

	public enuTransferStatus getTransferStatus() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getTransferStatus";
		return eTransferStatus;
	} // private enuTransferStatus getTransferStatus

	public String getZipFileName() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getZipFileName";
		return strZipFileName;
	} // private String getZipFileName

	// TODO polling über die File-Grüüe
	public boolean isSteady() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::isSteady";
		return flgSteadyFlag;
	} // private boolean isSteady

	public void Log4Debug() {
		logger.debug(SOSVfs_D_218.params(this.SourceFileName()));
		logger.debug(SOSVfs_D_219.params(this.SourceTransferName()));
		logger.debug(SOSVfs_D_220.params(this.TargetTransferName()));
		logger.debug(SOSVfs_D_221.params(this.TargetFileName()));
	}

	/**
	 *
	 * \brief MakeAtomicFileName
	 *
	 * \details
	 * This Method creates an intermediate File-Name, which is used on the target as the first filename
	 * After successfull completion of the whole transfer, this name will be renamed to the
	 * final targetFileName.
	 *
	 * An intermediate filename is mostly used to avoid that a file-trigger on the target-host
	 * will react to early on the transfer.
	 *
	 * \return the intermediate filename (without foldername) on the target-host
	 *
	 * @param ISOSFtpOptions.objO
	 * @return intermediate TargetTransferFileName
	 */
	public String MakeAtomicFileName(final ISOSFtpOptions objO) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::MakeAtomicFileName";
		String strAtomicSuffix = objO.getatomic_suffix().Value();
		String strAtomicPrefix = objO.getatomic_prefix().Value();
		strTargetTransferName = strTargetTransferName + strAtomicSuffix.trim();
		strTargetTransferName = strAtomicPrefix + strTargetTransferName;
		strAtomicFileName = strTargetTransferName.trim();
		return strAtomicFileName;
	} // private String MakeAtomicFileName

	private String MakeFileNameReplacing(final String pstrFileName) {
		String strR = adjustFileSeparator(pstrFileName);
		String strReplaceWith = objOptions.getreplacement().Value();
		try {
			strR = objOptions.getreplacing().doReplace(strR, strReplaceWith);
		}
		catch (Exception e) {
			logger.error(e.getLocalizedMessage(), new JobSchedulerException(SOSVfs_E_0150.get(), e));
			throw new JobSchedulerException(SOSVfs_E_0150.get(), e);
		}
		return strR;
	}

	public long NoOfBytesTransferred() {
		return lngNoOfBytesTransferred;
	}

	public void NoOfBytesTransferred(final long plngNoOfBytesTransferred) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::NoOfBytesTransferred";
		lngNoOfBytesTransferred = plngNoOfBytesTransferred;
		String strM = SOSVfs_D_0112.params(plngNoOfBytesTransferred);
		logger.info(strM);
	} // private void NoOfBytesTransferred

	protected String normalized(String str) {
		str = adjustFileSeparator(str);
		str = addFileSeparator(str);
		return str;
	}

	public void Options(final ISOSFtpOptions objOptions2) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::Options";
		objOptions = (SOSFTPOptions) objOptions2;
	} // private void Options

	private void RaiseException(final Exception e, final String pstrM) {
		logger.error(pstrM + " (" + e.getLocalizedMessage() + ")");
		throw new JobSchedulerException(pstrM, e);
	}

	private void RaiseException(final String pstrM) {
		this.TransferStatus(enuTransferStatus.transfer_aborted);
		logger.error(pstrM);
		throw new JobSchedulerException(pstrM);
	}

	@Deprecated// use getTargetfileNameAndPath
	public String RemoteFileName() {
		return strTargetFileName;
	}

	private void RenameSourceFile(final ISOSVirtualFile pobjSourceFile) {
		SOSConnection2OptionsAlternate objSourceOptions = objOptions.Source();
		if (objSourceOptions.ReplaceWhat.isDirty()) {
			String strReplaceWith = objSourceOptions.getreplacement().Value();
			try {
				File fleT = new File(strSourceFileName);
				String strParent = changeBackslashes(normalized(fleT.getParent()));
				String strSourceFileName1 = fleT.getName();
				strSourceFileName1 = changeBackslashes(strSourceFileName1); // Problems on windows: the path separator disapers
				String strNewSourceFileName = objSourceOptions.ReplaceWhat.doReplace(strSourceFileName1, strReplaceWith);
				if (strReplaceWith.startsWith("/") == false) {
					strNewSourceFileName = changeBackslashes(addFileSeparator(strParent) + strNewSourceFileName);
				}
				if (strNewSourceFileName.contains("/") && objOptions.makeDirs.isTrue()) { // sosftp-158
					String strP = normalized(new File(strNewSourceFileName).getParent());
					objDataSourceClient.mkdir(strP);
				}
				pobjSourceFile.rename(strNewSourceFileName);
				strRenamedSourceFileName = strNewSourceFileName;
			}
			catch (Exception e) {
				logger.error(e.getLocalizedMessage(), new JobSchedulerException(SOSVfs_E_0150.get(), e));
				throw new JobSchedulerException(SOSVfs_E_0150.get(), e);
			}
		}
	}

	private void RenameTargetFile(final String pstrTargetFileName) {
		if (!fileNamesAreEqual(pstrTargetFileName, objTargetTransferFile.getName(), true)) {
			if (pstrTargetFileName.contains("/") && objOptions.makeDirs.isTrue()) { // sosftp-158
				String strP = normalized(new File(pstrTargetFileName).getParent());
				try {
					objDataTargetClient.mkdir(strP);
				}
				catch (IOException e) {
					logger.error(e.getLocalizedMessage());
				}
			}
			objTargetTransferFile.rename(pstrTargetFileName);
		}
	}

	private String replaceVariables(final String pstrReplaceIn) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::replaceVariables";
		String strT = pstrReplaceIn;
		strT = strT.replace("$TargetFileName", MakeFullPathName(objOptions.TargetDir.Value(), strTargetFileName));
		strT = strT.replace("$TargetTransferFileName", MakeFullPathName(objOptions.TargetDir.Value(), strTargetTransferName));
		strT = strT.replace("$SourceFileName", MakeFullPathName(objOptions.SourceDir.Value(), strSourceFileName));
		strT = strT.replace("$SourceTransferFileName", MakeFullPathName(objOptions.SourceDir.Value(), strSourceTransferName));
		Properties objProp = objOptions.getTextProperties();
		objProp.put("TargetFileName", strTargetFileName);
		objProp.put("TargetTransferFileName", strTargetTransferName);
		objProp.put("SourceFileName", strSourceFileName);
		objProp.put("SourceTransferFileName", strSourceTransferName);
		objProp.put("$TargetDirName", objOptions.TargetDir.Value());
		objProp.put("TargetDirName", objOptions.TargetDir.Value());
		objProp.put("$SourceDirName", objOptions.SourceDir.Value());
		objProp.put("SourceDirName", objOptions.SourceDir.Value());
		strT = objOptions.replaceVars(strT);
		// TODO other patterns, like [date:] or others should replaced as well
		return strT;
	} // private String replaceVariables

	// Runnable
	@Override public void run() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::run";
		boolean flgNewConnectionUsed = false;
		try {
			//			logger.debug(SOSVfs_D_272.get());
			//			ISOSVFSHandler objVFS4Source = null;
			//			ISOSVFSHandler objVFS4Target = null;
			logger.info(SOSVfs_I_0108.params(strSourceFileName));
			flgNewConnectionUsed = false;
			if (objDataSourceClient == null) {
				setDataSourceClient((ISOSVfsFileTransfer) objConnPoolSource.getUnused());
				//				SOSConnection2OptionsAlternate objSourceConnect = objOptions.getConnectionOptions().Source();
				//				if (objSourceConnect.loadClassName.isDirty() == false) {
				//					objSourceConnect.loadClassName.Value(objOptions.getConnectionOptions().loadClassName.Value());
				//				}
				//
				//				objVFS4Source = VFSFactory.getHandler(objOptions.getDataSourceType());
				//				objVFS4Source.setSource();
				//
				//				// TODO use a Connection-Pool Object, to avoid to many connects and authenticates
				//				objVFS4Source.Connect(objSourceConnect);
				//				objVFS4Source.Authenticate(objSourceConnect);
				//				objDataSourceClient = (ISOSVfsFileTransfer) objVFS4Source;
				//				objVFS4Source.setSource();
				//				objVFS4Source.Options(objOptions);
			}
			if (objDataTargetClient == null & objOptions.NeedTargetClient() == true) {
				setDataTargetClient((ISOSVfsFileTransfer) objConnPoolTarget.getUnused());
				//				SOSConnection2OptionsAlternate objTargetConnectOptions = objOptions.getConnectionOptions().Target();
				//				if (objTargetConnectOptions.loadClassName.isDirty() == false) {
				//					objTargetConnectOptions.loadClassName.Value(objOptions.getConnectionOptions().loadClassName.Value());
				//				}
				//
				//				objVFS4Target = VFSFactory.getHandler(objOptions.getDataTargetType());
				//				objVFS4Target.setTarget();
				//				objVFS4Target.Connect(objTargetConnectOptions);
				//				objVFS4Target.Authenticate(objTargetConnectOptions);
				//				objDataTargetClient = (ISOSVfsFileTransfer) objVFS4Target;
				//				objVFS4Target.setTarget();
				//				objVFS4Target.Options(objOptions);
			}
			ISOSVirtualFile objSourceFile = objDataSourceClient.getFileHandle(strSourceFileName);
			if (objSourceFile.notExists() == true) {
				throw new JobSchedulerException(SOSVfs_E_226.params(strSourceFileName));
			}
			/**
			 * hier nicht verwenden, weil es zu spüt kommt.
			 */
			// if (CheckFileSizeIsChanging() == false) {
			// // TODO Exception auslüsen
			// return;
			// }
			//			// improve zeroByteFile handling in transactional mode
			//			if (objOptions.TransferZeroByteFiles() == false && objSourceFile.isEmptyFile()) {
			//				this.TransferStatus(enuTransferStatus.transfer_skipped);
			//				return;
			//			}
			//
			File subParent = null;
			String subPath = "";
			String strTargetFolderName = objOptions.TargetDir.Value();
			String localDir = objOptions.SourceDir.Value();
			boolean flgIncludeSubdirectories = objOptions.recursive.value();
			if (flgIncludeSubdirectories == true) {
				// TODO Das Erstellen des Verzeichnis muü eine separate Methode werden
				// überprüfen, ob das Verzeichnis auf den Target (-Server) existiert, wenn nicht dann soll das gleiche Verzeichnis generiert
				// werden
				if (objSourceFile.getParentVfs() != null && objSourceFile.getParentVfsFile().isDirectory()) {
					subPath = strSourceFileName.substring(localDir.length()); // Unterverzeichnisse sind alle Verzeichnisse unterhalb
					// der localDir
					subParent = new File(subPath).getParentFile();
					if (subParent != null) {
						subPath = adjustFileSeparator(subPath);
						subPath = subPath.substring(0, subPath.length() - new File(strSourceFileName.toString()).getName().length() - 1);
						// logger.debug(SOSVfs_D_227.params(subPath));
						// TODO nur feststellen, ob es den schon gibt. Neue Methode einführen, evtl. FileExists/Folderexists
						// String[] ftpFiles = objDataTargetClient.listNames(strTargetFolderName + "/" + subPath);
						// if (ftpFiles == null || ftpFiles.length == 0) {
						// File.separator führte zu Unterverzeichnissen mit führendem Backslash
						//objDataTargetClient.mkdir(strTargetFolderName + File.separator + subPath);
						objDataTargetClient.mkdir(strTargetFolderName + "/" + subPath);
						// }
					}
					else {
						subPath = "";
					}
				}
			}
			this.getTargetFile(objOptions); // TODO Namen ündern
			if (objOptions.transactional.value() == true) {
				this.setTransactionalLocalFile();
			}
			switch (objOptions.operation.value()) {
				case getlist:
					return;
				case delete:
					// TODO operation delete is not transactional
					objSourceFile.delete();
					logger.debug(SOSVfs_I_0113.params(strSourceFileName));
					this.setStatus(enuTransferStatus.deleted);
					return;
				case rename:
					// TODO operation rename is not transactional
					File fleT = new File(strSourceFileName);
					String strParent = changeBackslashes(normalized(fleT.getParent()));
					String strNewFileName = MakeFileNameReplacing(fleT.getName());
					if (strNewFileName.contains("/") && objOptions.makeDirs.isTrue()) { // sosftp-158
						String strP = normalized(new File(strNewFileName).getParent());
						objDataSourceClient.mkdir(strP);
					}
					strNewFileName = changeBackslashes(addFileSeparator(strParent) + strNewFileName);
					logger.debug(SOSVfs_I_150.params(strSourceFileName, strNewFileName));
					strTargetFileName = strNewFileName;
					objSourceFile.rename(strNewFileName);
					this.setStatus(enuTransferStatus.renamed);
					return;
				default:
					break;
			}
			ISOSVirtualFile objTargetFile = objDataTargetClient.getFileHandle(MakeFullPathName(objOptions.TargetDir.Value(), strTargetFileName));
			if (objOptions.CumulateFiles.isTrue()) {
				if (objOptions.CumulativeFileDelete.isTrue() && objOptions.flgCumulativeTargetDeleted == false) {
					objTargetFile.delete();
					objOptions.flgCumulativeTargetDeleted = true;
					logger.debug(String.format("cumulative file '%1$s' deleted.", strTargetFileName));
				}
			}
			objTargetFile.setModeAppend(objOptions.append_files.value());
			objTargetFile.setModeRestart(objOptions.ResumeTransfer.value());
			if (!fileNamesAreEqual(strTargetFileName, strTargetTransferName, false)) {
				objTargetTransferFile = objDataTargetClient.getFileHandle(MakeFullPathName(objOptions.TargetDir.Value(), strTargetTransferName));
			}
			else {
				objTargetTransferFile = objTargetFile;
			}
			if (objOptions.CumulateFiles.isTrue()) {
				objTargetTransferFile.setModeAppend(objOptions.append_files.value());
				objTargetTransferFile.setModeRestart(objOptions.ResumeTransfer.value());
			}
			if (objOptions.compress_files.value() == true) {
				objSourceTransferFile = objDataSourceClient.getFileHandle(strSourceTransferName);
				lngFileSize = objSourceTransferFile.getFileSize();
				lngOriginalFileSize = lngFileSize;
			}
			else {
				strSourceTransferName = getFileNameWithoutPath(strSourceTransferName);
				String strT = "";
				objSourceTransferFile = objDataSourceClient.getFileHandle(MakeFullPathName(getPathWithoutFileName(strSourceFileName) + strT,
						strSourceTransferName));
			}
			flgFileExists = objTargetFile.FileExists();
			if (flgFileExists == true) {
				this.setTargetFileAlreadyExists(true);
				if (objOptions.DoNotOverwrite() == true) { // kb 2012-06-29: check setting first, then file - existence
					logger.debug(SOSVfs_E_228.params(strTargetFileName));
					this.setNotOverwritten();
					return;
				}
			}
			this.doTransfer(objSourceTransferFile, objTargetTransferFile);
			if (objOptions.KeepModificationDate.isTrue()) {
				long pdteDateTime = objSourceFile.getModificationDateTime();
				if (pdteDateTime != -1) {
					objTargetFile.setModificationDateTime(pdteDateTime);
				}
			}
			if (objOptions.isAtomicTransfer() || objOptions.isReplaceReplacingInEffect()) {
				if (objOptions.transactional.isFalse()) {
					String strNewFileName = objTargetFile.getName();
					if (!fileNamesAreEqual(objTargetTransferFile.getName(), strNewFileName, false)) {
						flgFileExists = objTargetFile.FileExists();
						if (objOptions.overwrite_files.isTrue() && flgFileExists == true) {
							// hier werden Dateien gelöscht, vor dem umbenennen.
							// TODO Besser: auch erstmal umbenennen und dann erst löschen
							objTargetFile.delete();
						}
						RenameTargetFile(strNewFileName);
					}
				}
			}
			RenameSourceFile(objSourceFile);
		}
		catch (JobSchedulerException e) {
			String strT = SOSVfs_E_229.params(e);
			logger.error(strT);
			throw e;
		}
		catch (Exception e) {
			String strT = SOSVfs_E_229.params(e);
			logger.error(strT);
			throw new JobSchedulerException(strT, e);
		}
		finally {
			try {
				if (objDataSourceClient != null) {
					objDataSourceClient.getHandler().release();
				}
				if (objDataTargetClient != null) {
					objDataTargetClient.getHandler().release();
				}
				if (flgNewConnectionUsed == true) {
					if (objDataSourceClient != null) {
						objDataSourceClient.logout();
						objDataSourceClient.disconnect();
					}
					if (objDataTargetClient != null) {
						objDataTargetClient.logout();
						objDataTargetClient.disconnect();
					}
				}
			} catch (IOException e) {
				//
			}
		}
	}

	public String SecurityHash() {
		return strMD5Hash;
	}

	public void setAtomicFileName(final String pstrValue) {
		strAtomicFileName = pstrValue;
	}

	public void setConnectionPool4Source(final SOSVfsConnectionPool pobjConnP) {
		objConnPoolSource = pobjConnP;
	}

	public void setConnectionPool4Target(final SOSVfsConnectionPool pobjConnP) {
		objConnPoolTarget = pobjConnP;
	}

	/**
	 * \brief setobjDataSourceClient -
	 *
	 * \details
	 * setter
	 *
	 * @param objDataSourceClient the value for objDataSourceClient to set
	 */
	public void setDataSourceClient(final ISOSVfsFileTransfer pobjDataSourceClient) {
		objDataSourceClient = pobjDataSourceClient;
		lngFileModDate = -1;
		if (objDataSourceClient != null) {
			ISOSVirtualFile objFileHandle = objDataSourceClient.getFileHandle(strSourceFileName);
			if (objFileHandle != null) {
				lngFileModDate = objFileHandle.getModificationDateTime();
			}
			else {
			}
		}
	}

	/**
	 * \brief setobjDataTargetClient -
	 *
	 * \details
	 * setter
	 *
	 * @param pobjDataTargetClient1 the value for objDataTargetClient to set
	 */
	public void setDataTargetClient(final ISOSVfsFileTransfer pobjDataTargetClient1) {
		objDataTargetClient = pobjDataTargetClient1;
	}

	/**
	 *
	 * \brief setNoOfBytesTransferred
	 *
	 * \details
	 * This Method must be called only at the end of the transfer.
	 * Otherwise a call would result in a "FileSize"-Exception.
	 *
	 * \return void
	 *
	 * @param plngNoOfBytesTransferred
	 */
	public void setNoOfBytesTransferred(final long plngNoOfBytesTransferred) {
		lngNoOfBytesTransferred = plngNoOfBytesTransferred;
		SOSConnection2Options objConnectOptions = objOptions.getConnectionOptions();
		if (objOptions.transfer_mode.isAscii() || objConnectOptions.Source().transfer_mode.isAscii() || objConnectOptions.Target().transfer_mode.isAscii()
				|| objOptions.CheckFileSizeAfterTransfer.isFalse()) {
			// Probleme bei Ascii: linux -> windows mit cr/lf -> Datei wird groesser
		}
		else {
			if (lngFileSize <= 0) { // if the file is compressed, then the original filesize may be to big
				lngFileSize = objDataSourceClient.getFileHandle(strSourceFileName).getFileSize();
				lngOriginalFileSize = lngFileSize;
			}
			if (lngFileSize != plngNoOfBytesTransferred) {
				logger.error(SOSVfs_E_216.params(plngNoOfBytesTransferred, lngFileSize, strSourceFileName));
				this.setStatus(enuTransferStatus.transfer_aborted);
				throw new JobSchedulerException(SOSVfs_E_271.get());
			}
			if (lngOriginalFileSize != plngNoOfBytesTransferred) {
				logger.error(SOSVfs_E_216.params(plngNoOfBytesTransferred, lngOriginalFileSize, strSourceFileName));
				this.setStatus(enuTransferStatus.transfer_aborted);
				throw new JobSchedulerException(SOSVfs_E_270.get());
			}
		}
		this.setStatus(enuTransferStatus.transferred);
		// TODO Message "transferCompleted absetzen"
	}

	public void setNotOverwritten() {
		eTransferStatus = enuTransferStatus.notOverwritten;
		logger.warn(SOSVfs_D_0111.params(strSourceFileName));
	}
	
	public boolean isNotOverwritten() {
		return eTransferStatus == enuTransferStatus.notOverwritten;
	}

	public void setParent(final SOSFileList objFileList) {
		objParent = objFileList;
		objDataSourceClient = objParent.objDataSourceClient;
		objDataTargetClient = objParent.objDataTargetClient;
		if (objDataSourceClient != null) {
			ISOSVirtualFile sourceFile = objDataSourceClient.getFileHandle(strSourceFileName);
			setSourceFileProperties(sourceFile);
		}
	}
	
	public void setSourceFileProperties(ISOSVirtualFile file){
		lngOriginalFileSize = file.getFileSize();
		lngFileSize = lngOriginalFileSize;
		lngFileModDate = file.getModificationDateTime();
	}

	public void setRemoteFileName(final String pstrRemoteFileName) {
		strTargetFileName = pstrRemoteFileName;
	}

	public void setSourceFileName(final String pstrLocalFileName) {
		strSourceFileName = pstrLocalFileName;
	}

	public void setStatus(final enuTransferStatus peTransferStatus) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setStatus";
		String strM = "";
		eTransferStatus = peTransferStatus;
		switch (peTransferStatus) {
			case transferInProgress:
				strM = SOSVfs_I_0114.get();
				break;
			case waiting4transfer:
				strM = SOSVfs_I_0115.get();
				// TODO Message senden
				break;
			case transfer_skipped:
				dteEndTransfer = Now();
				strM = SOSVfs_I_0116.get();
				// TODO Message senden
				break;
			case transferring:
				strM = SOSVfs_I_0117.get();
				dteStartTransfer = Now();
				// TODO Message senden
				break;
			case transferred:
				strM = SOSVfs_I_0118.get();
				dteEndTransfer = Now();
				// TODO Message senden
				break;
			case transfer_aborted:
				strM = SOSVfs_I_0119.get();
				dteEndTransfer = Now();
				// TODO Message senden
				break;
			default:
				break;
		}
		if (isNotEmpty(strM)) {
			// TODO send not only transferred - messages. make it customizable
			//			if (objOptions.SendTransferHistory.value() == true) {
			//				if (objOptions.transactional.value() == false && peTransferStatus == enuTransferStatus.transferred) {
			//					sendTransferHistory();
			//				}
			//			}
			switch (peTransferStatus) {
				case transferInProgress:
					// logger.debug(String.format("%1$s for file %2$s, actual %3$,d bytes", strM, strSourceFileName, lngTransferProgress));
					break;
				default:
					strM = SOSVfs_I_0120.params(strM, strSourceFileName);
					break;
			}
		}
	} // private void TransferStatus

	public void setStatusEndTransfer() {
		this.setStatus(enuTransferStatus.transferred);
	}

	public void setStatusEndTransfer(final long plngNoOfBytesTransferred) {
		this.setNoOfBytesTransferred(plngNoOfBytesTransferred);
		this.setStatusEndTransfer();
	}

	public void setStatusStartTransfer() {
		this.setStatus(enuTransferStatus.transferring);
	}

	public void setSteady(final boolean pflgSteadyFlag) {
		flgSteadyFlag = pflgSteadyFlag;
	}

	public void setTransactionalLocalFile() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setTransactionalRemoteFile";
		flgTransactionalLocalFile = true;
	} // private void setTransactionalRemoteFile

	public void setTransactionalRemoteFile() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setTransactionalRemoteFile";
		flgTransactionalRemoteFile = true;
	} // private void setTransactionalRemoteFile

	/**
	 * \brief setlngTransferProgress -
	 *
	 * \details
	 * setter
	 *
	 * @param lngTransferProgress the value for lngTransferProgress to set
	 */
	public void setTransferProgress(final long plngTransferProgress) {
		lngTransferProgress = plngTransferProgress;
		this.setStatus(enuTransferStatus.transferInProgress);
		String lstrTargetFileName = strTargetFileName;
		if (objDataTargetClient.getHandler() instanceof SOSVfsZip) {
			lstrTargetFileName = SOSVfs_D_217.params(objOptions.remote_dir.Value(), strTargetFileName);
		}
		// logger.info(String.format("%1$,d bytes for file '%2$s' transferred to '%3$s'", lngTransferProgress, strSourceFileName,
		// lstrTargetFileName));
	}

	public void setTransferSkipped() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setTransferSkipped";
		eTransferStatus = enuTransferStatus.transfer_skipped;
		String strM = SOSVfs_D_0110.params(strSourceFileName);
		logger.debug(strM);
		objJadeReportLogger.info(strM);
	} // private void TransferStatus

	/**
	 *
		 *
		 * \brief SourceFileExists
		 *
		 * \details
		 * Check, wether a source file exists.
		 *
		 * \return boolean
		 *
	 */
	public boolean SourceFileExists() {
		boolean flgT = false;
		try {
			flgT = objDataSourceClient.getFileHandle(strSourceFileName).FileExists();
		}
		catch (Exception e) {
		}
		return flgT;
	}

	public String SourceFileName() {
		return strSourceFileName;
	}

	public String SourceTransferName() {
		return strSourceTransferName;
	}

	public String TargetFileName() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::TargetFileName";
		return strTargetFileName;
	} // private String TargetFileName

	public String TargetTransferName() {
		return strTargetTransferName;
	}

	public Properties getFileAttributesAsProperties() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getFileAttributesAsProperties";
		Properties objAttributesProperties = new Properties();
		//		boolean flgRet = false;
		//		if (flgTransferHistoryAlreadySent == true) {
		//			return flgRet;
		//		}
		//		flgTransferHistoryAlreadySent = true;
		//		if (objOptions.SendTransferHistory.isFalse()) {
		//			if (flgNoDataSent == false) {
		//				flgNoDataSent = true;
		//			}
		//			return flgRet;
		//		}
		SOSFileListEntry pobjEntry = this;
		String mandator = objOptions.mandator.Value(); // 0-
		String transfer_timestamp = EMPTY_STRING;
		try {
			transfer_timestamp = sos.util.SOSDate.getCurrentTimeAsString();
		}
		catch (Exception e) {
		} // 1- timestamp: Zeitstempel im ISO-Format
		/**
		 * this hack is tested for SUN-JVM only. No guarantee is made for other JVMs
		 */
		// TODO create a getPID method in shell class
		String pid = ManagementFactory.getRuntimeMXBean().getName();
		String strA[] = pid.split("@");
		pid = strA[0];
		String ppid = System.getProperty(conFieldPPID, "0");
		String operation = objOptions.operation.Value(); // 4- operation: send|receive
		SOSConnection2OptionsAlternate objS = objOptions.getConnectionOptions().Source();
		String localhost = objS.host.getLocalHostIfHostIsEmpty(); // 5- local host
		String localhost_ip = objS.host.getLocalHostAdressIfHostIsEmpty(); // 5-1- local host IP adresse
		String local_user = objS.user.getSystemUserIfUserIsEmpty(); // 6- local user
		SOSConnection2OptionsAlternate objT = objOptions.getConnectionOptions().Target();
		String remote_host = objT.host.getLocalHostIfHostIsEmpty(); // 7- remote host
		String remote_host_ip = objT.host.getLocalHostAdressIfHostIsEmpty(); // 7- remote host IP
		String remote_user = "";
		if (objT.AlternateOptionsUsed.value() == true) {
			remote_user = "(alternative) " + objT.Alternatives().user.Value(); // 8- remote host user
		}
		else {
			remote_user = objT.user.getSystemUserIfUserIsEmpty(); // 8- remote host user
		}
		String protocol = objT.protocol.Value(); // 9- protocol
		String port = objT.port.Value(); // 10- port
		String local_dir = objOptions.local_dir.Value();
		// String remote_dir = new File(this.strTargetFileName).getAbsolutePath();
		String remote_dir = objOptions.TargetDir.Value();
		String local_filename = pobjEntry.getSourceFilename(); // 13- file name
		String remote_filename = pobjEntry.getTargetFilename(); // 14- name
		if (isEmpty(remote_filename)) {
			remote_filename = "n.a.";
		}
		String fileSize = String.valueOf(pobjEntry.getFileSize());
		String md5 = pobjEntry.getMd5();
		String last_error_message = "";
		// last_error_message = clearCRLF(((getLogger().getError() != null && getLogger().getError().length() > 0) ? getLogger().getError()
		// : getLogger().getWarning())); // 15- last_error=|warn message
		// last_error_message = normalizedPassword(sosString.parseToString(last_error_message));
		String log_filename = objOptions.log_filename.Value();
		String jump_host = objOptions.jump_host.Value();
		String jump_host_ip = objOptions.jump_host.getHostAdress();
		String jump_port = objOptions.jump_port.Value();
		String jump_protocol = objOptions.jump_protocol.Value();
		String jump_user = objOptions.jump_user.Value();
		objAttributesProperties.put(conFieldGUID, UUID.randomUUID().toString()); // 1- GUID
		objAttributesProperties.put(conFieldMANDATOR, mandator); // 2- mandator: default SOS
		objAttributesProperties.put(conFieldTRANSFER_TIMESTAMP, transfer_timestamp); // 3- timestamp: Zeitstempel im ISO-Format
		objAttributesProperties.put(conFieldPID, pid); // 4- pid= Environment PID | 0 für Windows
		objAttributesProperties.put(conFieldPPID, ppid); // 5- ppid= Environment PPID | 0 für Windows
		objAttributesProperties.put(conFieldOPERATION, operation); // 6- operation: send|receive
		objAttributesProperties.put(conFieldLOCALHOST, localhost); // 7- local host
		objAttributesProperties.put(conFieldLOCALHOST_IP, localhost_ip); // 8- local host IP adresse
		objAttributesProperties.put(conFieldLOCAL_USER, local_user); // 9- local user
		objAttributesProperties.put(conFieldREMOTE_HOST, remote_host); // 10- remote host
		objAttributesProperties.put(conFieldREMOTE_HOST_IP, remote_host_ip); // 11- remote host IP
		objAttributesProperties.put(conFieldREMOTE_USER, remote_user); // 12- remote host user
		objAttributesProperties.put(conFieldPROTOCOL, protocol); // 13- protocol
		objAttributesProperties.put(conFieldPORT, port); // 14- port
		objAttributesProperties.put(conFieldLOCAL_DIR, local_dir); // 15- local dir
		objAttributesProperties.put(conFieldREMOTE_DIR, remote_dir); // 16- remote dir
		objAttributesProperties.put(conFieldLOCAL_FILENAME, local_filename); // 17- file name
		objAttributesProperties.put(conFieldREMOTE_FILENAME, remote_filename); // 18- file name
		objAttributesProperties.put(conFieldFILE_SIZE, fileSize); // 19 - file name
		objAttributesProperties.put(conFieldMD5, md5); // 20
		String status = pobjEntry.getStatusText();
		if (status.equalsIgnoreCase("transferred")) {
			status = "success";
		}
		objAttributesProperties.put(conFieldSTATUS, status); // 21- status=success|error
		objAttributesProperties.put(conFieldLAST_ERROR_MESSAGE, last_error_message); // 22
		objAttributesProperties.put(conFieldLOG_FILENAME, log_filename); // 23
		objAttributesProperties.put(conFieldJUMP_HOST, jump_host); // 24
		objAttributesProperties.put(conFieldJUMP_HOST_IP, jump_host_ip); // 25
		objAttributesProperties.put(conFieldJUMP_PORT, jump_port); // 26
		objAttributesProperties.put(conFieldJUMP_PROTOCOL, jump_protocol); // 27
		objAttributesProperties.put(conFieldJUMP_USER, jump_user); // 28
		// TODO custom-fields einbauen
		/**
		 * bei SOSFTP ist es moeglich "custom" Felder zu definieren, die in der Transfer History als Auftragsparameter mitgeschickt werden.
		 * Damit man diese Felder identifizieren kann, werden hier Parameter defininiert, die beim Auftrag dabei sind, aber keine
		 * "custom" Felder sind
		 *
		 * ? alternativ Metadaten der Tabelle lesen (Spalten) und mit den Auftragsparameter vergleichen
		 */
		return objAttributesProperties;
	} // private void getFileAttributesAsProperties

	public String toCsv() {
		Properties objProperties = getFileAttributesAsProperties();
		HashMap<String, String> objAttributesProperties = new HashMap(objProperties);
		addCSv(objAttributesProperties.get(conFieldGUID)); // 1- GUID
		addCSv(objAttributesProperties.get(conFieldMANDATOR)); // 2- mandator: default SOS
		addCSv(objAttributesProperties.get(conFieldTRANSFER_TIMESTAMP)); // 3- timestamp: Zeitstempel im ISO-Format
		addCSv(objAttributesProperties.get(conFieldPID)); // 4- pid= Environment PID | 0 für Windows
		addCSv(objAttributesProperties.get(conFieldPPID)); // 5- ppid= Environment PPID | 0 für Windows
		addCSv(objAttributesProperties.get(conFieldOPERATION)); // 6- operation: send|receive
		addCSv(objAttributesProperties.get(conFieldLOCALHOST)); // 7- local host
		addCSv(objAttributesProperties.get(conFieldLOCALHOST_IP)); // 8- local host IP adresse
		addCSv(objAttributesProperties.get(conFieldLOCAL_USER)); // 9- local user
		addCSv(objAttributesProperties.get(conFieldREMOTE_HOST)); // 10- remote host
		addCSv(objAttributesProperties.get(conFieldREMOTE_HOST_IP)); // 11- remote host IP
		addCSv(objAttributesProperties.get(conFieldREMOTE_USER)); // 12- remote host user
		addCSv(objAttributesProperties.get(conFieldPROTOCOL)); // 13- protocol
		addCSv(objAttributesProperties.get(conFieldPORT)); // 14- port
		addCSv(objAttributesProperties.get(conFieldLOCAL_DIR)); // 15- local dir
		addCSv(objAttributesProperties.get(conFieldREMOTE_DIR)); // 16- remote dir
		addCSv(objAttributesProperties.get(conFieldLOCAL_FILENAME)); // 17- file name
		addCSv(objAttributesProperties.get(conFieldREMOTE_FILENAME)); // 18- file name
		addCSv(objAttributesProperties.get(conFieldFILE_SIZE)); // 19 - file name
		addCSv(objAttributesProperties.get(conFieldMD5)); // 20
		addCSv(objAttributesProperties.get(conFieldSTATUS)); // 21- status=success|error
		addCSv(objAttributesProperties.get(conFieldLAST_ERROR_MESSAGE)); // 22
		addCSv(objAttributesProperties.get(conFieldLOG_FILENAME)); // 23
		addCSv(objAttributesProperties.get(conFieldJUMP_HOST)); // 24
		addCSv(objAttributesProperties.get(conFieldJUMP_HOST_IP)); // 25
		addCSv(objAttributesProperties.get(conFieldJUMP_PORT)); // 26
		addCSv(objAttributesProperties.get(conFieldJUMP_PROTOCOL)); // 27
		addCSv(objAttributesProperties.get(conFieldJUMP_USER)); // 28
		// Diff to the format of the transfer history as order
		SOSOptionTime objModTime = new SOSOptionTime(null, null, null, "", "", false);
		objModTime.value(lngFileModDate);
		addCSv(objModTime.getTimeAsString(lngFileModDate));
		return strCSVRec;
	}

	private String toHexString(final byte[] b) {
		char[] hexChar = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
		int length = b.length * 2;
		StringBuffer sb = new StringBuffer(length);
		for (byte element : b) {
			// oberer Byteanteil
			sb.append(hexChar[(element & 0xf0) >>> 4]);
			// unterer Byteanteil
			sb.append(hexChar[element & 0x0f]);
		}
		return sb.toString();
	}

	@Override public String toString() {
		String strT;
		try {
			strT = SOSVfs_D_214.params(this.getTargetFileNameAndPath(), this.SourceFileName(), this.NoOfBytesTransferred(), objOptions.operation.Value());
		}
		catch (RuntimeException e) {
			logger.error(e.getLocalizedMessage());
			strT = "???";
		}
		return strT;
	}

	public void TransferStatus(final enuTransferStatus peTransferStatus) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::TransferStatus";
		this.setStatus(peTransferStatus);
	} // private void TransferStatus

	public void VfsHandler(final ISOSVfsFileTransfer pobjVfs) {
		objVfsHandler = pobjVfs;
	}
	
	private boolean fileNamesAreEqual(String filenameA, String filenameB, boolean caseSensitiv) {
		String a = filenameA.replaceAll("[\\\\/]+", "/");
		String b = filenameB.replaceAll("[\\\\/]+", "/");
		return (caseSensitiv) ? a.equals(b) : a.equalsIgnoreCase(b);
	}
	
	public boolean isTargetFileAlreadyExists() {
		return targetFileAlreadyExists;
	}

	public void setTargetFileAlreadyExists(boolean targetFileAlreadyExists) {
		this.targetFileAlreadyExists = targetFileAlreadyExists;
	}
}