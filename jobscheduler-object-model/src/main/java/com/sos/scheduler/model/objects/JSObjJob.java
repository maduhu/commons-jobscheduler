package com.sos.scheduler.model.objects;
import java.io.File;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

import org.apache.log4j.Logger;

import com.sos.JSHelper.Exceptions.JobSchedulerException;
import com.sos.VirtualFileSystem.Interfaces.ISOSVirtualFile;
import com.sos.scheduler.model.LanguageDescriptorList;
import com.sos.scheduler.model.SchedulerObjectFactory;

/**
* \class JSObjectJob
*
* \brief JSObjectJob -
*
* \see http://www.sos-berlin.com/doc/en/scheduler.doc/xml/job.xml
*
* \details
*
* This junit-test will add two jobs to the current jobscheduler instance.
* First job ist a Java-API job and the second is a java-script driven job.
*
* There is no checking in this junit-test wether the jobs exists.
* If the job already exist it will be overwritten without any further notice.
*
* \return void
*
  \code
	@Test
	public final void testCreateAddJobs() {
		JSObjJob objJavaJob = objFactory.createJob();
		objJavaJob.setName("checkIfWritable");
		objJavaJob.setOrder(false);

		Description objDesc = objFactory.createJobDescription();
		Include objDescInclude = objFactory.createInclude();
		objDescInclude.setFile("jobs/JobSchedulerCanWrite.xml");
		objDesc.getContent().add(objDescInclude);
		objJavaJob.setDescription(objDesc);

		JSObjScript objScript = objFactory.createScript();
		objScript.setLanguage("java");
		objScript.setJavaClass("sos.scheduler.file.JobSchedulerCanWrite");
		objJavaJob.setScript(objScript);

		Params objParams = objFactory.setParams(new String[] { "file", "jobs/JobSchedulerCanWrite.xml" });
		objJavaJob.setParams(objParams);

		// javascript job
		JSObjJob objJavaScriptJob = objFactory.createJob();
		objJavaScriptJob.setName("hello");
		objJavaScriptJob.setOrder(false);

		JSObjScript objJSScript = objFactory.createScript();
		objJSScript.setLanguage("javascript");
		objJSScript.getContent().add("spooler_log.info('hello');");
		objJavaScriptJob.setScript(objJSScript);

		JSCmdAddJobs objAJ = objFactory.createAddJobs();
		objAJ.getJob().add(objJavaJob);
		objAJ.getJob().add(objJavaScriptJob);

		objAJ.run();
		try {
			objAJ.getAnswerWithException();
		}
		catch (JSCommandOKException e) {
			// TODO: show added jobs
		}
		catch (JSCommandErrorException e) {
			fail(e.getMessage());
		}
	}
* \endcode
*
* <p style="text-align:center">
* <br />---------------------------------------------------------------------------
* <br /> APL/Software GmbH - Berlin
* <br />##### generated by ClaviusXPress (http://www.sos-berlin.com) #########
* <br />---------------------------------------------------------------------------
* </p>
* \author oh
* @version $Id$03.02.2011
* \see reference
*
* Created on 03.02.2011 16:35:42
 */
/**
 * @author oh
 *
 */
public class JSObjJob extends Job {
	private final String			conClassName			= this.getClass().getSimpleName();
	@SuppressWarnings("unused")
	private static final String		conSVNVersion			= "$Id$";
	private final Logger			logger					= Logger.getLogger(this.getClass());
	public static final String[]	ValidLanguages4Job		= LanguageDescriptorList.getLanguages4APIJobs();
	public static final String[]	ValidLanguages4Monitor	= LanguageDescriptorList.getLanguages4Monitor();
	public static final String		InternalAPIMethodNames	= "spooler_process_before;spooler_process_after;spooler_task_before;spooler_task_after;";
	public static final String		MonitorMethodNames		= "spooler_task_before;spooler_task_after;spooler_process_before;spooler_process_after";
	// TODO should be defined as enum at the Attribute visible
	public static enum enuVisibilityTypes {
		enuIsVisible, enuIsNotVisible, enuIsNeverVisible;
		private static String[]	strVisibilityText	= new String[] { "", "yes", "no", "never" };
		public static boolean	IsMandatory			= false;
		public static String	I18nKey				= "job.visible";

		public static String[] getTexts() {
			return strVisibilityText;
		} // public static String getTexts
	}
	public final static String	fileNameExtension	= ".job.xml";
	private Script				objScript			= null;

	public JSObjJob(final SchedulerObjectFactory schedulerObjectFactory) {
		super();
		objFactory = schedulerObjectFactory;
		super.strFileNameExtension = fileNameExtension;
	}

	public JSObjJob(final SchedulerObjectFactory schedulerObjectFactory, final Job origOrder) {
		objFactory = schedulerObjectFactory;
		super.strFileNameExtension = fileNameExtension;
		setObjectFieldsFrom(origOrder);
		afterUnmarshal();
	}

	public JSObjJob(final SchedulerObjectFactory schedulerObjectFactory, final ISOSVirtualFile pobjVirtualFile) {
		super();
		super.strFileNameExtension = fileNameExtension;
		objFactory = schedulerObjectFactory;
		final Job objJob = (Job) unMarshal(pobjVirtualFile);
		//		InputStream objInputStream = pobjVirtualFile.getFileInputStream();
		//		JSObjScript objJSScript = objFactory.createScript();
		//		objJSScript.setLanguage("javascript");
		//		objJSScript.getContent().add("spooler_log.info('hello');");
		//		objJob.setScript(objJSScript);
		setObjectFieldsFrom(objJob);
		//		this.setScript(objJSScript);
		setHotFolderSrc(pobjVirtualFile);
		//		afterUnmarshal();
	}

	private void afterUnmarshal() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::afterUnmarchal";
		if (this.getDescription() != null) {
			removeEmptyContentsFrom(this.getDescription().getContent());
		}
		if (this.getScript() != null) {
			removeEmptyContentsFrom(this.getScript().getContent());
		}
		if (this.getMonitor() != null) {
			for (final Job.Monitor objMonitor : this.getMonitor()) {
				if (objMonitor.getScript() != null) {
					removeEmptyContentsFrom(objMonitor.getScript().getContent());
				}
			}
		}
	} // public afterUnmarshal

	@Override public Description getDescription() {
		if (description == null) {
			description = objFactory.createJobDescription();
			setDirty();
		}
		return description;
	}

	@Override public Script getScript() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getScript";
		if (script == null) {
			objScript = objFactory.createScript();
			script = objScript;
			setDirty();
		}
		else {
			objScript = script;
		}
		return script;
	} // private JSObjScript getScript

	/**
	 *
	 * \brief removeEmptyContentsFrom
	 *
	 * \details
	 * Some objects contain cdata as well as other objects, so that
	 * unmarshalling creates for every spaces around the other objects
	 * empty cdata nodes. These empty cdata nodes are removed.
	 *
	 * \return void
	 *
	 * @param objList
	 */
	private void removeEmptyContentsFrom(final List<Object> objList) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::removeEmptyContentsFrom";
		final List<String> emptyContents = new ArrayList<String>();
		for (final Object listItem : objList) {
			if (listItem instanceof String && ((String) listItem).trim().length() == 0) {
				emptyContents.add((String) listItem);
			}
		}
		objList.removeAll(emptyContents);
	} // private removeEmptyContentsFrom

	/**
	 *
	 * \brief setOrder
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pflgIsOrder
	 */
	public void setOrder(final boolean pflgIsOrder) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setOrder";
		if (canUpdate() == false)
			return;
		setDirty();
		if (pflgIsOrder == true) {
			this.setOrder("yes");
		}
		else {
			this.setOrder("no");
		}
	} // public void setOrder

	/**
	 *
	 * \brief setStopOnError
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pflgIsStoppingOnError
	 */
	//	public void setStopOnError(final boolean pflgIsStoppingOnError) {
	//		@SuppressWarnings("unused")
	//		final String conMethodName = conClassName + "::setStopOnError";
	//		if (pflgIsStoppingOnError == true) {
	//			this.setStopOnError("yes");
	//		}
	//		else {
	//			this.setStopOnError("no");
	//		}
	//		setDirty();
	//	} // public void setStopOnError
	/**
	 *
	 * \brief setForceIdleTimeout
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pflgIsForcedIdleTimeout
	 */
	public void setForceIdleTimeout(final boolean pflgIsForcedIdleTimeout) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setForceIdleTimeout";
		if (canUpdate() == false)
			return;
		setDirty();
		if (pflgIsForcedIdleTimeout == true) {
			this.setForceIdleTimeout("yes");
		}
		else {
			this.setForceIdleTimeout("no");
		}
	} // public void setForceIdleTimeout

	/**
	 *
	 * \brief setTemporary
	 *
	 * \details
	 *
	 * \return void
	 *
	 * @param pflgIsTemporary
	 */
	public void setTemporary(final boolean pflgIsTemporary) {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::setTemporary";
		if (canUpdate() == false)
			return;
		setDirty();
		if (pflgIsTemporary == true) {
			this.setTemporary("yes");
		}
		else {
			this.setTemporary("no");
		}
		setDirty();
	} // public void setTemporary

	public boolean hasScript() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::hasScript";
		objScript = getScript();
		if (objScript == null) {
			final JobSchedulerException objJSException = new JobSchedulerException("Job has no script.");
			logger.error("", objJSException);
			throw objJSException;
		}
		// TODO else if (objScript.getLanguage()... ) {
		// }
		return true;
	}

	public boolean getEnabled() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::name";
		// TODO attribut gehlt im JAXb?
		return true;
	} // private booelan getEnabled name

	public boolean isJobChainJob() {
		return isOrderDrivenJob();
	}

	public boolean isOrderDrivenJob() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::isOrderDrivenJob";
		if (order == null) {
			return false;
		}
		else {
			return getYesOrNo(order);
		}
	} // private boolean isOrderDrivenJob

	@Override public String getProcessClass() {
		String strT = super.processClass;
		if (strT == null || strT.length() <= 0) {
			strT = "";
		}
		return avoidNull(strT);
	}

	@Override public JSObjParams getParams() {
		JSObjParams objP = new JSObjParams(objFactory, super.getParams());
		return objP;
	}

	@Override public Process getProcess() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getProcess";
		Process objP = super.getProcess();
		if (objP == null) {
			super.setProcess(new Process());
			objP = super.getProcess();
			setDirty();
		}
		return objP;
	} // private List getProcess

	public void setTasks(final String pstrV) {
		if (canUpdate() == false)
			return;
		setDirty();
		BigInteger intT = new BigInteger(pstrV);
		super.setTasks(intT);
	}

	public String getMintasks() {
		return BigInt2String(super.getMinTasks());
	}

	public String getTasksAsString() {
		return BigInt2String(super.getTasks());
	}

	public void setMintasks(final String mintasks) {
		if (canUpdate() == false)
			return;
		setDirty();
		BigInteger bigI = new BigInteger(mintasks);
		super.setMinTasks(bigI);
	}

	@Override public RunTime getRunTime() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getProcess";
		RunTime objP = super.getRunTime();
		if (objP == null) {
			super.setRunTime(new RunTime());
			objP = super.getRunTime();
			setDirty();
		}
		return objP;
	} // public List getRunTime

	public JSObjRunTime getRunTimeObj() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getProcess";
		RunTime objP = super.getRunTime();
		if (objP == null) {
			super.setRunTime(new RunTime());
			objP = super.getRunTime();
			setDirty();
		}
		JSObjRunTime objR = new JSObjRunTime(objFactory, objP);
		return objR;
	} // public List getRunTime

	public String getJobName() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::getJobName";
		String name = this.getHotFolderSrc().getName();
		name = name.substring(0, name.indexOf(JSObjJob.fileNameExtension));
		name = new File(name).getName();
		return name;
		// return String;
	} // private String getJobName

	public String getJobNameAndTitle() {
		String strT = this.getJobName();
		if (this.isDisabled() == true) {
			// TODO i18n
			// strT += " (" + sos.scheduler.editor.app.Messages.getLabel("disabled") + ")";
			strT += " (disabled)";
		}
		String strV = this.getTitle();
		if (strV != null && strV.isEmpty() == false) {
			strT += " - " + this.getTitle();
		}
		return strT;
	}

	public boolean isDisabled() {
		@SuppressWarnings("unused") final String conMethodName = conClassName + "::isDisabled";
		return false;
	} // private boolean isDisabled

	@Override public void setVisible(final String visible) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setVisible(visible);
	}

	@Override public void setWarnIfLongerThan(final String warnIfLongerThan) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setWarnIfLongerThan(warnIfLongerThan);
	}

	@Override public void setWarnIfShorterThan(final String pstrWarnIfShorterThan) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setWarnIfShorterThan(pstrWarnIfShorterThan);
	}

	public int languageAsInt(final String language) {
		if (language != null) {
			String strT = language.toLowerCase();
			for (int i = 0; i < ValidLanguages4Job.length; i++) {
				if (ValidLanguages4Job[i].equalsIgnoreCase(strT)) {
					return i;
				}
			}
		}
		return 0;
	}

	private String languageAsString(final int language) {
		String strR = "";
		if (language >= 0) {
			strR = ValidLanguages4Job[language];
		}
		return strR;
	}

	public String getLanguage(final int language) {
		return ValidLanguages4Job[language];
	}

	public int getLanguage() {
		String strT = this.getScript().getLanguage();
		return languageAsInt(strT);
	}

	public String getLanguageAsString(final int language) {
		return languageAsString(language);
	}

	public void setLanguage(final String pstrLanguage) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.setLanguage(languageAsInt(pstrLanguage));
	}

	public void setLanguage(final int language) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.getScript().setLanguage(languageAsString(language));
		//		setScript();
		//		if (_script == null && language != NONE) {
		//			// init script element
		//			_script = new Element("script");
		//			if (_type == Editor.MONITOR) {
		//				// Element monitor = _job.getChild("monitor");
		//				Element monitor = _job;
		//				if (monitor == null) {
		//					monitor = new Element("monitor");
		//					_job.addContent(monitor);
		//				}
		//				monitor.addContent(_script);
		//			}
		//			else
		//				_job.addContent(_script);
		//		}
		//
		//		if (_script != null) {
		//
		//			if (!isJava()) {
		//				_script.removeAttribute("java_class");
		//				_script.removeAttribute("java_class_path");
		//			}
		//
		//			if (language != NONE)
		//				Utils.setAttribute("language", languageAsString(language), _script, _dom);
		//
		//			_dom.setChanged(true);
		//
		//			setChangedForDirectory();
		//		}
	}

	public boolean isJava() {
		return languageAsString(getLanguage()).equalsIgnoreCase("java");
	}

	public boolean isInternalAPIJob() {
		return languageAsString(getLanguage()).equalsIgnoreCase("shell") == false;
	}

	@Override public void setName(final String name) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setName(name);
	}

	public void setJavaClass(final String javaClass) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.getScript().setJavaClass(javaClass);
	}

	public void setClasspath(final String classpath) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.getScript().setJavaClassPath(classpath);
	}

	public void setHistoryOnProcess(final String pstrValue) {
		this.setSettings().setHistoryOnProcess(pstrValue);
		setDirty();
	}

	public void setHistory(final String pstrValue) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.setSettings().setHistory(pstrValue);
	}

	public void setHistoryWithLog(final String pstrValue) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.setSettings().setHistoryWithLog(pstrValue);
	}

	public void setOrdering(final String ordering) {
		if (canUpdate() == false)
			return;
		setDirty();
		getMonitor().get(0).setOrdering(new BigInteger(ordering));
	}

	private String getYesNoText(final String pstrS) {
		String strR = pstrS;
		if (strR == null || strR.trim().length() <= 0) {
			strR = "no";
		}
		return strR;
	}

	public void setMailOnError(final String text) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.setSettings().setMailOnError(getYesNoText(text));
	}

	public void setMailOnWarning(final String text) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.setSettings().setMailOnWarning(getYesNoText(text));
	}

	public void setMailOnSuccess(final String text) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.setSettings().setMailOnSuccess(getYesNoText(text));
	}

	public void setMailOnProcess(final String text) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.setSettings().setMailOnProcess(getYesNoText(text));
	}

	public void setMailOnDelayAfterError(final String text) {
		if (canUpdate() == false)
			return;
		this.setSettings().setMailOnDelayAfterError(getYesNoText(text));
	}

	public void setLogMailTo(final String text) {
		if (canUpdate() == false)
			return;
		this.setSettings().setLogMailTo(getYesNoText(text));
	}

	public void setLogMailBcc(final String text) {
		if (canUpdate() == false)
			return;
		this.setSettings().setLogMailBcc(getYesNoText(text));
	}

	public void setLogMailCc(final String text) {
		if (canUpdate() == false)
			return;
		this.setSettings().setLogMailCc(getYesNoText(text));
	}
	// see class LogLevel
	public final static String[]	ValidLogLevels	= new String[] { "info", "debug1", "debug2", "debug3", "debug4", "debug5", "debug6", "debug7", "debug8",
			"debug9", ""							};

	public String getLogLevel () {
		return this.getSettings().getLogLevel().value();
	}
	public void setLogLevel(final String text) {
		if (canUpdate() == false)
			return;
		this.setSettings().setLogLevel(LogLevel.fromValue(text));
	}

	@Override public void setIdleTimeout(final String idleTimeout) {
		if (canUpdate() == false)
			return;
		super.setIdleTimeout(idleTimeout);
	}

	public void setForceIdletimeout(final boolean forceIdleTimeout) {
		if (canUpdate() == false)
			return;
		super.setTimeout(setYesOrNo(forceIdleTimeout));
	}

	public void setStopOnError(final boolean stopOnError) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setStopOnError(setYesOrNo(stopOnError));
	}

	public void setReplace(final boolean replace) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setReplace(setYesOrNo(replace));
	}

	public boolean isReplace() {
		return getYesOrNo(super.getReplace());
	}

	public void setTemporary1(final boolean temporary) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setTemporary(setYesOrNo(temporary));
	}

	public boolean isTemporary() {
		return getYesOrNo(super.getTemporary());
	}

	//	public void setMintasks(final String mintasks) {
	//		super.setMintasks(mintasks);
	//	}
	//
	//	public String getMintasks() {
	//		return avoidNull(super.getMinTasks());
	//	}
	public void setVisible1(final String visible) {
		if (canUpdate() == false)
			return;
		setDirty();
		super.setVisible(visible);
	}

	@Override public String getVisible() {
		return avoidNull(super.getVisible());
	}

	public void setFile(final String file) {
		if (canUpdate() == false)
			return;
		setDirty();
		this.getProcess().setFile(file);
	}

	public String getHistoryWithLog() {
		if (this.getSettings() != null) {
			return avoidNull(this.getSettings().getHistoryWithLog());
		}
		return "";
	}

	public String getHistory() {
		if (this.getSettings() != null) {
			return avoidNull(avoidNull(this.getSettings().getHistory()));
		}
		return "";
	}

	public String getHistoryOnProcess() {
		if (this.getSettings() != null) {
			return avoidNull(this.getSettings().getHistoryOnProcess());
		}
		return "";
	}

	public String getMonitorName() {
		//	todo	return Utils.getAttributeValue("name", _parent);
		return "";
	}

	public void setMonitorName(final String name) {
		//	TODO	Utils.setAttribute("name", name, _parent);
	}

	public void setMailOnError(final String pstrValue, final String pstrDefaultValue) {
		this.getSettings().setMailOnError(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}
	JobSettings	objSettings	= null;

	@Override public JobSettings getSettings() {
		JobSettings objS = super.getSettings();
		if (objS == null) {
			throw new JobSchedulerException("is null");
		}
		return objS;
	}

	public JobSettings setSettings() {
		if (settings == null) {
			settings = new JobSettings();
		}
		setDirty();
		return settings;
	}

	public String getMailOnError() {
		try {
			return avoidNull(getSettings().getMailOnError());
		}
		catch (Exception e) {
		}
		return "";
	}

	public void setMailOnWarning(final String pstrValue, final String pstrDefaultValue) {
		this.setSettings().setMailOnWarning(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}

	public String getMailOnWarning() {
		try {
			return avoidNull(getSettings().getMailOnWarning());
		}
		catch (Exception e) {
		}
		return "";
	}

	public void setMailOnProcess(final String pstrValue, final String pstrDefaultValue) {
		this.setSettings().setMailOnProcess(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}

	public String getMailOnProcess() {
		try {
			return avoidNull(getSettings().getMailOnProcess());
		}
		catch (Exception e) {
		}
		return "";
	}

	public void setMailOnSuccess(final String pstrValue, final String pstrDefaultValue) {
		this.setSettings().setMailOnSuccess(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}

	public String getMailOnSuccess() {
		try {
			return avoidNull(getSettings().getMailOnSuccess());
		}
		catch (Exception e) {
		}
		return "";
	}

	public void setMailOnDelayAfterError(final String pstrValue, final String pstrDefaultValue) {
		this.setSettings().setMailOnDelayAfterError(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}

	public String getMailOnDelayAfterError() {
		try {
			return avoidNull(getSettings().getMailOnDelayAfterError());
		}
		catch (Exception e) {
		}
		return "";
	}

	public void setLogMailTo(final String pstrValue, final String pstrDefaultValue) {
		this.setSettings().setLogMailTo(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}

	public String getLogMailTo() {
		try {
			return avoidNull(getSettings().getLogMailTo());
		}
		catch (Exception e) {
		}
		return "";
	}

	public void setLogMailCC(final String pstrValue, final String pstrDefaultValue) {
		this.setSettings().setLogMailCc(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}

	public String getLogMailCC() {
		try {
			return avoidNull(getSettings().getLogMailCc());
		}
		catch (Exception e) {
		}
		return "";
	}

	public void setLogMailBcc(final String pstrValue, final String pstrDefaultValue) {
		this.setSettings().setLogMailBcc(OneOfUs(pstrValue, pstrDefaultValue));
		setDirty();
	}

	public String getLogMailBCC() {
		try {
			return avoidNull(getSettings().getLogMailBcc());
		}
		catch (Exception e) {
		}
		return "";
	}

	public String OneOfUs(final String pstrValue, final String pstrDefaultValue) {
		if (isNotEmpty(pstrValue)) {
			return pstrValue;
		}
		return pstrDefaultValue;
	}

	public boolean isSetbackDelay() {
		return this.getDelayOrderAfterSetback().size() > 0;
	}

	public boolean isNotEmpty(final String pstrValue) {
		return pstrValue != null && pstrValue.trim().length() > 0;
	}
}
